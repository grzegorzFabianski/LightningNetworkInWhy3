(* 
  This file focuses on `Gamma` - our simplified modelling of blockchain, over which out implementation of Lightning Network operates. It consists of the following modules:
 * `Gamma` - defines how gamma process messages
 * `Evaluator` - defines how much money party holds in given state of gamma. This concept is explained in length in accompanying paper.
 * `GammaInvariant` defines `gammaCoherent` -- the internal invariant of gamma.
 * `GammaBasicLemmas` - statements of simple auxiliary lemmas about the gamma.
 * `GammaInvariantLemmas` - statements of preservation of `gammaCoherent`.
 * `GammaProcessMsgLemmas` - statements of lemmas that describe the behavior of `gammaProcessMessage`.
 * `ExistsFreshIdLemmas` - statements of lemmas that fresh id could always be found.
 * `EvaluatorBasicLemmas` - statements of simple auxiliary lemmas about the evaluator.
 * `EvaluatorOnChainForPartyLemmas` - statements of lemmas that help us estimate how `immediateLossesInMoveOwnCoinsMsgs` changes when party signs a message
 * `EvaluatorPreservationLemmas` - statement of key evaluator property : when gamma processes a message, this never decreases the evaluator value for any party
 * `EvaluatorAdditionalExportedLemmas` - statement of few simple facts about evaluator, used in later proofs
 * `EvaluatorEquivalentStatementLemmas` - statement that two formulations of the Evaluator are equal: `partyExpectations` and `partyExpectations2`.

Later `_Proofs` modules contain proofs of facts stated in `_Lemmas` modules. This is a part of the Statement-Proof separation
convention explained in detail at the beginning of the `ClosingWorksLemmas` module.

*)


(* Definition of Gamma - provides definition of `gammaProcessMsg`, which defines how gamma processes messages*)
module Gamma
  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  use list.Nth
  
  use basicTypes.Compare
  use list.Append
  use list.List
  use signaturesFunctionality.SignaturesFunctionality

  (*In this module we define methods (i.e. functions) for `gammaStateT` - the of of the gamma (defined in `basicTypes.BasicTypes`).
  The most important one is `gammaProcessMsg`, which defines how gamma processes messages.*)

  (*In order to apply a message to gamma, we first show how to apply a message to a single contract.
    This is done in function `contractProcessMsg`. The function is split into two parts -- the first part (i.e. 
    functions `verificationCheck`, `msgApplicable`, and `timeCheck`) checks if the message is applicable to 
    the contract, and the second part computes the new contracts created by the message (implemented in  `evalOut`).
    The advantage of this approach is that `evalOut` does not depend on the input contract. 
    Once we have the function `contractProcessMsg`, we can implement `gammaProcessMsg` by applying `contractProcessMsg`
    to the matching contract in gamma. The matching contract is computed using the function `expectedContractStatus`.*)


  (*We start with some simple low-level functions.*)

  let predicate goodMsg (msg : msgToGammaT) = 
    match msg with
    | OpenDispute (hsplit, _, _) ->
       goodSplit hsplit.split
    | MoveOwnCoinsOnChain (args, _, _, _) ->
      0 <= args.amount <= args.totalAmount
    | _ -> true
    end

  (*Gamma uses two different types of ids: 
    1) It identifies `PublicKeyAccount`s by their `idT`s, but
    2) It identifies channels by the `transferFromPublicKeyAccountT` that founded them. 
  The following two functions express this logic.*)
  
  (*This function checks if a given contract is a `PublicKeyAccount.
    If so, it returns the `idT` of the account; otherwise it returns `None`.*)
  let function extractAccountId (contract : contractStatusT) : option idT =
  match contract with
    | PublicKeyAccount _ _ x -> Some x
    | _ -> None
  end
  
  (*This function checks if a given contract is one of the lighting specific contracts. 
  If it is, then it returns the `transferFromPublicKeyAccountT` which serves as a channel id; otherwise it returns `None`.*)
  let function extractChannelId (contract : contractStatusT) : option transferFromPublicKeyAccountT = 
    match contract with 
      | Normal id -> Some id 
      | DisputeOpen mSplit -> Some mSplit.id
      | _ -> None
    end
  
  (*Comparator for `option transferFromPublicKeyAccountT`*)
  let function compareOptionArgs (x y : option transferFromPublicKeyAccountT) =
  ensures { result <-> x = y }
    compareOption compareArgs x y
  
  (*Checks if a given contract is a lighting-related contract with  a given `id`*)
  let function hasGivenChannelId (id : transferFromPublicKeyAccountT) (x : contractT) =
    compareOptionArgs (Some id) x.contractStatus.extractChannelId
  
  (*Extract a lightning-specific contract from gamma by its id.*)
  let function extractChannelByIdFromGamma (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) : option contractT = 
    let x = filter (hasGivenChannelId id) gamma.activeContracts in 
    match x with 
      | Cons ans _ -> Some ans
      | Nil -> None 
    end
  
  let predicate applicableRevokeMsg (sigState : signatureFunctionalityT) (msplit : conditionalOutputT) (msg : msgToGammaT) =
  match msg with
      | Revoke (msplit2, sig, sig2, _) ->
        compareConditionalOutputs msplit msplit2 &&
        verify_comp msplit.partyCond (SignableRevoke msplit) sig sigState &&
        verify_comp (other msplit.partyCond) (SignableClosure msplit) sig2 sigState
      | _ -> false
    end
  
  (*Get all used `idT`s from gamma*)
  let function usedIds (g : gammaStateT) : list idT = 
    catMaybes ((map extractAccountId) (g.allContracts))
  
  let function contractStatuses (gamma : gammaStateT) : (list contractStatusT) = 
    map (fun x -> x.contractStatus) (gamma.activeContracts)

  (*Checks if a given contract has already been spent on `gamma`. For this we check if 
  the contract is present in `allContracts` but not in `contractStatuses`, i.e. that it has 
  been present on gamma at some point, but it is not present anymore.*)  
  predicate isSpent (contract : contractStatusT) (gamma : gammaStateT) =
    let statuses = gamma.contractStatuses in 
    member contract gamma.allContracts
    && (not (member contract statuses))
  
  (* See the comment for basicTypes.ListLibrary.num_occ_comp for explanation of the _comp convention *)
  let function isSpent_comp (contract : contractStatusT) (gamma : gammaStateT) =
  ensures { result <-> isSpent contract gamma }
    let statuses = gamma.contractStatuses in 
    member_comp compareContractStatus contract gamma.allContracts
    && (not (member_comp compareContractStatus contract statuses))

  let function splitValue (split : splitT) : amountT = split.condOutput.channelCapacity

  (*Next, we implement the function `expectedContractStatus`, which computes the expected contract status for a given msg
   Note that the output of this function does not contain the information about the last transition time of the contract.
   This information needs to be extracted from gamma*)

  let function expectedContractStatusMoveOwnCoins (args : transferFromPublicKeyAccountT) =
      PublicKeyAccount args.totalAmount args.sender args.fundingId

  let function expectedContractStatus (msg : msgToGammaT) = 
    match msg with
    | ClaimAfterTimeout (msplit, _, _)
    | Revoke (msplit, _, _, _) ->
      DisputeOpen msplit
    | OpenDispute (hsplit, _, _) ->
      Normal hsplit.split.condOutput.id
    | MoveOwnCoinsOnChain (args, _, _, _) ->
      expectedContractStatusMoveOwnCoins args
    end

  
  (*Next, we implement the three checks mentioned in the introduction `verificationCheck`, `msgApplicable`, and `timeCheck`*)
  (* `verificationCheck` checks if the `msg` is correctly signed by the parties involved*)
  let predicate verificationCheck (msg : msgToGammaT) (sigState : signatureFunctionalityT) = 
    match msg with
    | ClaimAfterTimeout (msplit, sigSpender, _) ->
      verify_comp msplit.partyCond (SignableClosure msplit) sigSpender sigState
    | Revoke (msplit, sig, sigSpender, _) ->
      verify_comp msplit.partyCond (SignableRevoke msplit) sig sigState &&
      verify_comp (other msplit.partyCond) (SignableClosure msplit) sigSpender sigState
    | OpenDispute (halfSigned, sig, _) ->
      verify_comp (other halfSigned.split.condOutput.partyCond) (SignableSplit halfSigned.split) halfSigned.sigUnCond sigState &&
      verify_comp (halfSigned.split.condOutput.partyCond) (SignableSplit halfSigned.split) sig sigState
    | MoveOwnCoinsOnChain (args, sig, _, _) ->
      verify_comp args.sender (SignableTX args) sig sigState
    end
  
  
  (*Check if a given message can be applied to a given contract status*)
  let function msgApplicable (contractStatus : contractStatusT) (msg : msgToGammaT) =
    goodMsg msg &&
    compareContractStatus contractStatus (expectedContractStatus msg)
  
  (*Checks if all time constraints are satisfied*)
  let predicate timeCheck (msg : msgToGammaT) (lastTxTime : timeT) (time : timeT) =
    match msg with
    | ClaimAfterTimeout _ ->
      time >= lastTxTime + channelTimelock
    | _ -> true
    end

  (* Next, we define the `evalOut` function mentioned in the introductory paragraph. 
     It produces all the outputs created by a given message (assuming that it is applicable). *)
  let function evalOut (msg : msgToGammaT) : list contractStatusT = 
    match msg with
    | ClaimAfterTimeout (msplit, _, newId) ->
      (Cons (PublicKeyAccount msplit.amountCond msplit.partyCond newId) Nil) 
    | Revoke (msplit, _, _ , newId) -> 
      (Cons (PublicKeyAccount msplit.amountCond (other msplit.partyCond) newId) Nil)
    | OpenDispute (halfSigned, _ , newId) ->
       Cons (DisputeOpen (halfSigned.split.condOutput)) 
      (Cons (PublicKeyAccount halfSigned.split.amountUnCond (other halfSigned.split.condOutput.partyCond) newId) Nil)
    | MoveOwnCoinsOnChain (args, _, newId, newId2)  ->
      match args.destination with
      | OtherParty ->
        (Cons (PublicKeyAccount args.amount (other args.sender) newId2)
        (Cons (PublicKeyAccount (args.totalAmount-args.amount) args.sender newId) Nil) 
        )
      | Channel ->
        (
          Cons (Normal args)
            (Cons (PublicKeyAccount (args.totalAmount - args.amount) args.sender newId) Nil)
        )
      | Void -> Cons (PublicKeyAccount (args.totalAmount - args.amount) args.sender newId) Nil
      end
    end

  (* This function combines the simpler functions and shows how to process the `msg` on a single contract.*)
  let function contractProcessMsg (input : contractT)
                                        (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT)
                                        : option (list contractStatusT) =
    if not verificationCheck msg sigState then None else
    if not msgApplicable input.contractStatus msg then None else
    if not timeCheck msg input.lastContractTransitionTime time then None else
    Some (evalOut msg)


  (*In the next part of the file we extend contractProcessMsg to work on the entire gamma, rather than on a single input message. 
    This process needs to take care and ensure that all PublicKeyAccounts have unique `idT`s. For this reason, we need to check 
    if the `msg` does not introduce any output `idT`s that are already present in gamma.*)

  (* Extract all `idT`s describing outputs created when processing a given `msg` *)
  let function extractIds (msg : msgToGammaT) : (list idT) = 
  match msg with 
    | ClaimAfterTimeout (_, _, id) -> Cons id Nil 
    | OpenDispute (_, _, id) -> Cons id Nil 
    | Revoke (_, _, _, id) -> Cons id Nil 
    | MoveOwnCoinsOnChain (_, _, id1, id2) ->
      Cons id1 (Cons id2 Nil)
  end

  (*Check if a given `idT` does not appear on gamma*)
  let predicate idFreshForGamma (gamma : gammaStateT) (id : idT)  = 
    num_occ_comp compareIDs id gamma.usedIds = 0
  
  (*Check if `extractIds msg` do not already appear on gamma, and are pairwise distinct. *)
  let predicate checkFreshness (msg : msgToGammaT) (gamma : gammaStateT)  =
    forallL (idFreshForGamma gamma) (extractIds msg) &&
    forallL (fun x -> num_occ_comp compareIDs x (extractIds msg) = 1) (extractIds msg)

  (*In order to process a message on gamma, we need to remove the spent contract and add the new ones.
    For this we use the following two functions: `gammaSpendContract` and `gammaInsertContracts`*)
  
  (*Remove a given contract from gamma. *)
  let function gammaSpendContract (gamma : gammaStateT) (toSpend : contractT) =
  requires { member toSpend gamma.activeContracts } 
  {activeContracts = removeOne_comp compareSimpleChannel toSpend gamma.activeContracts; allContracts = gamma.allContracts}
  
  (*Insert given contracts to gamma. *)
  let function gammaInsertContracts (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  let fullChannels = map (fun x -> {contractStatus = x; lastContractTransitionTime = currentTime}) channels in 
  {activeContracts = fullChannels ++ gamma.activeContracts; allContracts = channels ++ gamma.allContracts}

  (*This is the basic variant of gammaProcessMsg -- it tries to apply the `msg` to `gamma`. It returns the new state of gamma, or `None` if the msg is not applicable.*)
  let function gammaProcessMsgFresh (gamma : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) : option gammaStateT =
    if not (checkFreshness msg gamma) then None else
    let input = expectedContractStatus msg in
    if isSpent_comp input gamma then None else
    let filtered = filter (fun x -> compareContractStatus x.contractStatus input) gamma.activeContracts in
    match filtered with
    | Nil -> None
    | Cons inputFull _ ->
      assert { inputFull.contractStatus = input };
      match contractProcessMsg inputFull msg sigState time with
      | None -> None
      | Some newChannels ->
        let gammaWithSpentInput = gammaSpendContract gamma inputFull in 
        let gammaWithNewInputs = gammaInsertContracts gammaWithSpentInput newChannels time in 
        Some gammaWithNewInputs
      end
    end
  
  (* This function tires to apply `gammaProcessMsgFresh` to `gamma`. If it fails `gamma` remains unchanged, i.e. it drops the inapplicable messages.*)
  let function gammaProcessMsgFreshFull (gamma : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) : gammaStateT = 
  match gammaProcessMsgFresh gamma msg sigState time with 
    | None -> gamma
    | Some newGamma -> newGamma
  end
    
  (*Since providing a message with fresh `idT`s a responsibility of the adversary, we sometimes want to distinguish between inapplicable messages and
  messages with non-fresh `idT`s. The inapplicable messages are simply dropped, but the messages with non-fresh `idT`s result in an `AdversaryError`. 
  This is the standard way to handle such situations in the framework, and it is implemented in `gammaProcessMsg`, which returns an element of 
  the type `gammaOrAdversaryErrorT`, defined below:*)

  type gammaOrAdversaryErrorT = CorrectGamma gammaStateT | AdversaryError
  
  let function gammaProcessMsg (gamma : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) : gammaOrAdversaryErrorT = 
    if not checkFreshness msg gamma then AdversaryError else
    CorrectGamma (gammaProcessMsgFreshFull gamma msg sigState time)

  (*`gammaProcessMsg` is the main function of this module. Below we provide a few auxiliary functions that are not used in the implementation of 
    `gammaProcessMsg`, but are sometimes used in the project*)


  (*Since our gamma only tracks a subset of gamma, it might happen that a party receives some money from the untracked part. This is implemented as the following function*)
  let function addMoneyFromVoid (gamma : gammaStateT) (id : idT) (amount : amountT) (p : partyT) (currentTime : timeT) : gammaStateT = 
  if not (idFreshForGamma gamma id) then gamma else 
  let newStatus = PublicKeyAccount amount p id in
  let newChannelFull = {contractStatus = newStatus; lastContractTransitionTime = currentTime} in
  {activeContracts = Cons newChannelFull gamma.activeContracts; allContracts = Cons newStatus gamma.allContracts}
  
  (* The following function is used for simplifying proofs.
    When  `isSome gammaProcessMsgFreshFull` then `gammaProcessMsgFreshFull = Some gammaProcessMsgFresh`.
    Direct version does check if the message is applicable.*)
  let function gammaProcessMsgDirect (gamma : gammaStateT) (msg : msgToGammaT) (time : timeT) (ch : contractT) : gammaStateT = 
  (*We need to check if `ch` appears on gamma to satisfy the precondition of `removeOne_comp`*)
  if not (member_comp compareSimpleChannel ch gamma.activeContracts) then gamma else (
    let newChannels = evalOut msg in
    let chs = removeOne_comp compareSimpleChannel ch gamma.activeContracts in
    {activeContracts = (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) newChannels) ++ chs; allContracts = newChannels ++ gamma.allContracts}
  )

  (*This function negates `isSpent` and accepts `transferFromPublicKeyAccountT` rather than `msgToGammaT`. 
    This idiom appears in many places, so we implement it as a function. *)
  let predicate inputUnspent (args : transferFromPublicKeyAccountT) (gamma : gammaStateT) =
    let input = expectedContractStatusMoveOwnCoins args in 
    not (isSpent_comp input gamma)
  
  (* This function checks if a party is the funder of a transaction. *)
  let predicate isFunder (args : transferFromPublicKeyAccountT) (p : partyT) =
    compareParties p args.sender
  
  (*A transaction is valid if its input is unspent so far, and if it is present on chain*)
  let predicate goodFunding  (gamma : gammaStateT) (args : transferFromPublicKeyAccountT) = 
    transferFromPublicKeyAccountCorrect args &&
    inputUnspent args gamma
  
  (* Sometimes is convenient to treat channels whose opening messages are pending (unprocessed) as already opened (if such a pending transaction is correct and has unspent inputs). 
     The function `computeVirtualContractStatus` computes the current status of a channel opened by `funding, under this assumption.*)
  let function computeVirtualContractStatus (funding : transferFromPublicKeyAccountT) (gamma : gammaStateT) (p : partyT) (sigs : signatureFunctionalityT) : option contractStatusT = 
    match funding.destination with 
    | Void -> None
    | OtherParty -> None 
    | Channel -> 
      match extractChannelByIdFromGamma gamma funding with 
      | Some ans -> Some ans.contractStatus
      | None ->
        if goodFunding gamma funding && isFunder funding p && isSigned_comp p (SignableTX funding) sigs
          then Some (Normal funding)
          else None
      end
    end

  (*A version of `computeVirtualContractStatus` that returns the full contract.
    The `lastContractTransitionTime` is set in the following way:
    a) If the contract is already present on gamma, then its `lastContractTransitionTime` is taken from gamma.
    b) Otherwise, it is set to `currentTime`.*)
  let function computeVirtualContract (funding : transferFromPublicKeyAccountT) (gamma : gammaStateT) (p : partyT) (currentTime : timeT) (sigs : signatureFunctionalityT) : option contractT =
    match funding.destination with 
    | Void -> None
    | OtherParty -> None 
    | Channel -> 
      match extractChannelByIdFromGamma gamma funding with 
      | Some ans -> Some ans
      | None ->
        if goodFunding gamma funding && isFunder funding p && isSigned_comp p (SignableTX funding) sigs
          then Some {contractStatus = Normal funding; lastContractTransitionTime = currentTime}
          else None
      end
    end 
     
  (*This function checks if a given contractStatus does not appear on gamma*) 
  let predicate contractStatusFreshForGamma (gamma : gammaStateT) (channel : contractStatusT) = 
    not (member_comp compareContractStatus channel gamma.allContracts)

  (* Used by the adversary to replace ids in msgToGammaT *)
  (* Note that signatures in msgToGammaT do not sign ids intentionally, so that the adversary can replace the ids *)
  let function replaceIdsInMsg (msg : msgToGammaT) (id1 id2 : idT) : msgToGammaT =
    match msg with
    | OpenDispute (split, sig, _) -> OpenDispute (split, sig, id1)
    | ClaimAfterTimeout (split, sig, _) -> ClaimAfterTimeout (split, sig, id1)
    | Revoke (split, sig, sigSpender, _) -> Revoke (split, sig, sigSpender, id1)
    | MoveOwnCoinsOnChain (args, sig, _, _) -> MoveOwnCoinsOnChain (args, sig, id1, id2)
    end
end (*Gamma *)

module Evaluator
  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  (*use basicTypes.ListFunctions*)
  
  use list.Nth
  
  use basicTypes.Compare
  use export Gamma
  
  use signaturesFunctionality.SignaturesFunctionality

  (*In this module, we define the function `worstCaseChannelResolutionFull`, which serves as the "Evaluator", i.e. 
  the function that estimates the amount of money that a party can get extract from gamma in the worst-case scenario.
  Intuitively, this function computes how much money a party "owns" in the blockchain. See the paper for more details.*)
  

  (*We want to start with a few functions that evaluate splits. Before, we do this let us briefly reiterate the lifetime of a contract*)
  (*A contract is founded with a `MoveOwnCoinsOnChain` message, which outputs a `Normal` contract.
    Such a contract can be closed in two steps: 
    1) In the first step one of the parties submits a `splitT` signed by both parties. 
       After receiving such a message, gamma spends the `Normal` contract, and creates a `DisputeOpen` contract, and 
       pays out the unconditional funds to the unconditional party (by creating a `PublicKey` contract.
    2) A `DisputeOpen` contract can be closed in one of two ways: 
       a) The unconditional party submits a revocation signed by the conditional party. In this case the unconditional party receives the conditional funds
          (in addition to the unconditional funds that it has already received during the dispute opening).
       b) After the channelTimelock, the conditional party can send a `ClaimAfterTimeout` message, and claim the conditional funds 
          (provided that the unconditional party has not submitted a revocation). *)
 
  (*The following function computes how much many the party a party `p` receives when gamma opens a dispute with a given split*)
  (*This corresponds to item 1) in the enumeration above, i.e. it involves only the unconditional
    funds paid immediately after accepting a split, and not the conditional funds that can be claimed after a dispute, or by a revocation.*)
  let function unCondPayment (p : partyT) (split : splitT) = 
    if compareParties split.condOutput.partyCond p then 0 else split.amountUnCond

  (*This next function computes how much money a party can receive after a split has been accepted on gamma*)
  (*It involves only the conditional funds described in item 2) of the enumeration above*)
  function expectedSplitResolutionWhenDispute (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (split : conditionalOutputT) : amountT  = 
    if compareParties split.partyCond p then
      (*`p` is the conditional party*)
      if num_occ split revsSigned > 0
        then 0 (*If the party has revoked the split, then it has to expect that the other party will submit this revocation and receive all funds*)
        else split.amountCond (*If the party has not revoked the split, then it will be able to claim `split.amountCond` after the channelTimelock*)
    else
      (*`p` is the unconditional party*)
      if num_occ split revsReceived > 0
        then split.amountCond (*If the party stores the revocation for the current split, it can submit it and receive `split.amountCond`. *)
        else 0 (*Otherwise, the party will not be able to claim any extra funds (besides ms.amountUncond which it should have already received when opening the dispute.*)

  (*Computable version of `expectedSplitResolutionWhenDispute`*) 
  let function expectedSplitResolutionWhenDispute_comp (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (ms : conditionalOutputT) : amountT  = 
  ensures { result = expectedSplitResolutionWhenDispute p revsSigned revsReceived ms }
    if compareParties ms.partyCond p then
      if num_occ_comp compareConditionalOutputs ms revsSigned > 0 then 0
      else ms.amountCond
    else
      if num_occ_comp compareConditionalOutputs ms revsReceived > 0 then (ms.amountCond)
      else 0
  
  (*This function computes the total amount of money both unconditional (item 1) and conditional (item 2) that a party will receive from a split*)
  let function expectedSplitResolutionTotal (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT) : amountT  = 
    expectedSplitResolutionWhenDispute_comp p revsSigned revsReceived s.condOutput +
    unCondPayment p s
  
  (*This function checks if we can open a dispute with a given split*)
  let predicate checkApplicableSplitToNormal (channelId : transferFromPublicKeyAccountT) (split : splitT) =
    split.splitValue = channelId.amount &&
    compareArgs split.condOutput.id channelId &&
    goodSplit split
  
  (*Similar to `expectedSplitResolutionTotal`, but returns `None` if the split is not applicable to the channel*)
  let function expectedSplitResolutionOption (p : partyT) (id : transferFromPublicKeyAccountT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT) : option amountT  = 
    if checkApplicableSplitToNormal id s then
      Some (expectedSplitResolutionTotal p revsSigned revsReceived s)
    else None
  
  let function extractSplitFromSignableRevoke (s : signableT) : option conditionalOutputT = 
  match s with
    | SignableRevoke s -> Some s
    | _ -> None
  end
  
  let function extractSplitFromSignableSplit (s : signableT) : option splitT = 
  match s with
    | SignableSplit s -> Some s
    | _ -> None
  end
  
  let function extractArgsFromSignableTX (s : signableT) : option transferFromPublicKeyAccountT = 
  match s with 
    | SignableTX args -> Some args
    | _ -> None
  end

  lemma extractSplitFromSignableRevokeUnique : forall s msg. extractSplitFromSignableRevoke msg = Some s -> msg = SignableRevoke s
  lemma extractSplitFromSignableSplitUnique : forall s msg. extractSplitFromSignableSplit msg = Some s -> msg = SignableSplit s  
  lemma extractArgsFromSignableTxUnique : forall s msg. extractArgsFromSignableTX msg = Some s -> msg = SignableTX s

  (*Extract all the splits that the party has revoked*)
  let function extractRevokedSplits (signedMsgs : list signableT) : list conditionalOutputT =
  ensures { forall s. num_occ s result > 0 <-> num_occ (SignableRevoke s) signedMsgs > 0 }
    let result = catMaybes (map extractSplitFromSignableRevoke signedMsgs) in 
    assert {forall x. member x result -> member (Some x) (map extractSplitFromSignableRevoke signedMsgs)};
    catMaybes (map extractSplitFromSignableRevoke signedMsgs)
  
  (*Extracts all the split that a party has signed*)
  let function extractSignedSplits (signedMsgs : list signableT) : list splitT =
  ensures {forall s. num_occ s result > 0 <-> num_occ (SignableSplit s) signedMsgs > 0}
    catMaybes (map extractSplitFromSignableSplit signedMsgs)
  
  (*Extract all the revocations that a party has received and stores*)
  let function extractRevocationsReceived (p : partyT) (sigs : signatureFunctionalityT) (receivedRevocations : revokedSplitsListT) : list conditionalOutputT =
    map snd (filter (fun rev -> verify_comp (other p) (SignableRevoke (snd rev)) (fst rev) sigs) receivedRevocations)
  
  (*This function checks if a given message on a queue to gamma is a correct and early enough revocation message*)
  let predicate correctAndEarlyEnoughRevokeMsg (sigState : signatureFunctionalityT) (msplit : conditionalOutputT) (deadline : timeT) (msgAndTime : (msgToGammaT, timeT)) =
    snd msgAndTime < deadline && applicableRevokeMsg sigState msplit (fst msgAndTime)
  
  let predicate compareCondOutputSplit (ms : conditionalOutputT) (s : splitT) =
    compareConditionalOutputs ms s.condOutput
    
  (*This is a direct contract evaluator that only assumes that the party owns what it stores in its `PublicKeyAccount`s *)
  let function immediateAccountEvaluation (channel : contractStatusT) (p : partyT) = 
    match channel with 
      | PublicKeyAccount amount owner _ -> if compareParties owner p && amount >= 0 then amount else 0
      | _ -> 0 
    end
    
  (*This is the key function of the evaluator. It computes the worst-case scenario for a party `p` in a given channel*)
  let function worstCaseChannelResolution (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordStrictT)
                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
    let channel = channelFull.contractStatus in 
    let lastTransitionTime = channelFull.lastContractTransitionTime in 
    let revsSigned  : list conditionalOutputT = extractRevokedSplits (getSignedBy sigs p.recordOwner) in
    let splitsSigned : list splitT = extractSignedSplits (getSignedBy sigs p.recordOwner) in
    let revsReceived : list conditionalOutputT =  extractRevocationsReceived p.recordOwner sigs p.receivedRevocations in
    let bestHsSplit = p.bestSplitReceived in 
    let hsResult = (expectedSplitResolutionTotal p.recordOwner revsSigned revsReceived) bestHsSplit.split in (*take minimum with what we wanted *)
    
    match channel with
      | Normal id ->
      (*After performing some basic checks, we compute the minimum of the total (i.e. both conditional and unconditional) values of
          a) bestHsSplit
          b) all the splits it has signed.*)
        if not compareParties bestHsSplit.split.condOutput.partyCond p.recordOwner then 0 else (*wrong partyRecord *) 
        if not verify_comp (other bestHsSplit.split.condOutput.partyCond) (SignableSplit bestHsSplit.split) bestHsSplit.sigUnCond sigs then 0 else (*wrong partyRecord *)
        if not checkApplicableSplitToNormal id bestHsSplit.split then 0 else (* wrong partyRecord  and check of right id *)
        let signedSplitsExpectedResolutions = catMaybes (map (expectedSplitResolutionOption p.recordOwner id revsSigned revsReceived) (splitsSigned)) in
        minListAux hsResult signedSplitsExpectedResolutions
      | DisputeOpen msplit ->
        (*In this case we need to compute the conditional value of `msplit`.
          However, computing the set of available revocations is more involved:
          In order to see what revocations we can send, we need to check the time:
           a) If it is early enough, we can send any revocation from `revsReceived`.
           b) If it is too late to send a revocation that would arrive on time (i.e. before channelTimelock) 
              on gamma, we have to limit the available revocations the ones that are already on the 
              queue and will arrive to gamma in a timely manner*)
        if not (existsL (compareCondOutputSplit msplit) splitsSigned) then 0 else 
        if not goodSplit bestHsSplit.split then 0 else (* check of right id, wrong partyRecord *)
        if not compareArgs bestHsSplit.split.condOutput.id msplit.id then 0 else
        if not goodConditionalOutput msplit then 0 else (* basicFail *)
        let availableRevocations =
        (*if it is early enough, we can still send all our revocations*)
        if lastWoken + deltaNet + deltaWake < lastTransitionTime + channelTimelock then revsReceived else
        (*otherwise we check if there is a revocation on the queue, that will get to gamma on time*)
        if existsL (correctAndEarlyEnoughRevokeMsg sigs msplit (lastTransitionTime + channelTimelock - deltaNet)) msgs
          then (Cons msplit Nil) (*if yes, then we can treat msplit as revocable*)
          else Nil (*if no then, we have no revocations available*)
        in 
        let result = expectedSplitResolutionWhenDispute_comp p.recordOwner revsSigned availableRevocations msplit in 
        result
      | PublicKeyAccount amount owner _ ->
        (*Evaluating `PublicKeyAccount` is straightforward: If `p` is the owner, then `p` gets all the funds*)
        if compareParties owner p.recordOwner && amount >= 0 then amount else 0
      end
  
  (*This is the same as `worstCaseChannelResolution`, but it takes a general `partySplitsAndRevocationsRecord`. 
    If the party does not track any channel, then it can only count on what it has in its `PubKeyAccount`s*)
  let function worstCaseChannelResolutionFull (sigs : signatureFunctionalityT) (channel : contractT)
                                              (op : partySplitsAndRevocationsRecordGeneralT)
                                              (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  match makeStrict op with
  | None -> immediateAccountEvaluation channel.contractStatus op.recordOwnerG
  | Some pg -> worstCaseChannelResolution sigs channel pg lastWoken msgs 
  end
  
    
  (*Now, we extend the evaluator to work on the entire gamma (and not only on one contract).*)    
  let function moneyInChannels (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
     (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) : amountT = 
  sum (map (fun x -> worstCaseChannelResolution sigs x p lastWoken msgs) gamma.activeContracts)
  
  (*A version of moneyInChannels that works on the general `partySplitsAndRevocationsRecordGeneralT`.*)
  let function moneyInChannelsFull (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
     (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) : amountT = 
  sum (map (fun x -> worstCaseChannelResolutionFull sigs x p lastWoken msgs) gamma.activeContracts)
  
  
  (* Next, we need to deduct the losses that will result from the messages that we have already signed, 
     but have not yet been processed by gamma (e.g. because they are pending on the message queue).*)
  
  (* This function checks how much funding a party has committed to a transaction.*)
  let function fundsInvested (args : transferFromPublicKeyAccountT) (p : partyT) = 
    if compareParties p args.sender then args.amount else 0
    
  (* The following function computes the main output created by a transaction when it goes through 
     (as opposed to the auxiliary output which is a simple `PublicKeyAccount` account with the reminder of 
     the funds from the input `PublicKeyAccount` *)
  let function transactionOutput (args : transferFromPublicKeyAccountT) = 
    match args.destination with 
      | OtherParty -> Some (PublicKeyAccount args.amount (other args.sender) placeholderId)
      | Channel -> Some (Normal  args)
      | Void -> None
    end
    
  (* The net balance of a transaction *)
  let function transactionNetLoss (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT)
                            (p : partySplitsAndRevocationsRecordStrictT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
    if not transferFromPublicKeyAccountCorrect args then 0 else
    let losses = fundsInvested args p.recordOwner in 
    let output = transactionOutput args in
    let currentTime = 0 (*The output does not depend on the choice of currentTime, so 0 could be replaced with `any timeT`, but it would make the proofs more complicated.*) in 
    let potentialGains = 
      match output with 
        | None -> 0 
        | Some output' ->
           let outputFullChannel = {contractStatus = output'; lastContractTransitionTime = currentTime} in
           worstCaseChannelResolution sigs outputFullChannel p lastWoken msgs
      end in 
    let gains = if isFunder args p.recordOwner then potentialGains else 0 in
    losses - gains

  (*The same as `transactionNetLoss`, but it takes a general `partySplitsAndRevocationsRecordGeneralT`*)
  let function transactionNetLossFull (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT)
                            (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
    if not transferFromPublicKeyAccountCorrect args then 0 else
    let losses = fundsInvested args p.recordOwnerG in 
    let output = transactionOutput args in 
    let currentTime = 0 (*any timeT*) in
    let potentialGains = 
      match output with 
        | None -> 0 
        | Some output' ->
           let outputFullChannel = {contractStatus = output'; lastContractTransitionTime = currentTime} in
           worstCaseChannelResolutionFull sigs outputFullChannel p lastWoken msgs 
      end in 
    let gains = if isFunder args p.recordOwnerG then potentialGains else 0 in 
    losses - gains
    
  (*This extracts from the `signatureFunctionalityT` all the well-formed transactions that a party has signed*)
  let function getSignedGoodTransactions (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partyT) = 
    let mySigs = getSignedBy sigs p in 
    let args = catMaybes (map extractArgsFromSignableTX mySigs) in 
    let goodArgs = filter (goodFunding gamma) args in 
    makeUnique_comp compareArgs goodArgs

  (*We sum the net losses of all the transactions that a party has signed*)  
  let function lossesInMoveOwnCoinsMsgs
    (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  let signedGoodArgs = getSignedGoodTransactions gamma sigs p.recordOwner in 
  sum (map (fun x -> transactionNetLoss x sigs p lastWoken msgs) signedGoodArgs)  
  
  (*The same as `lossesInMoveOwnCoinsMsgs`, but it takes a general `partySplitsAndRevocationsRecordGeneralT`*)
  let function lossesInMoveOwnCoinsMsgsFull
    (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  let signedGoodArgs = getSignedGoodTransactions gamma sigs p.recordOwnerG in 
  sum (map (fun x -> transactionNetLossFull x sigs p lastWoken msgs) signedGoodArgs)  
  
  (*Combine the losses and the money in channels to get the final evaluation.*)
  let function partyExpectations (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  moneyInChannels gamma sigs p lastWoken msgs - 
  lossesInMoveOwnCoinsMsgs gamma sigs p lastWoken msgs
  
  (*The same as `partyExpectations`, but it takes a general `partySplitsAndRevocationsRecordGeneralT`*)
  let function partyExpectationsFull (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  moneyInChannelsFull gamma sigs p lastWoken msgs - 
  lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs
  
  (*This finishes the definition of the evaluator. However, in some parts of the proof it will be useful to use an alternative definition, 
    which we define below. Later in lemma `partyExpectationsEqual` we show that the two definitions are equivalent.*) 

  (*==== Alternative evaluator ====*)

  (*In this alternative approach to the evaluator, we split the final sum into two parts: 
    a) `immediatePartyExpectations` that depends on `transferFromPublicKeyAccountT` that we have signed but not on the split and revocations. 
    b) `channelExpectations` that depends on splits and revocations that we have sung but not on `transferFromPublicKeyAccountT`*)
    
  (*First, we evaluate our assets on chain, that are not locked in any channel, i.e. the funds stored in `PublicKeyAccount`s*)
  let function immediateAmountOnChain (gamma : gammaStateT) (p : partyT) = 
    sum (map (fun x -> immediateAccountEvaluation x.contractStatus p) gamma.activeContracts)
    
  (*Next, we evaluate transactions net losses, but we only use the immediate evaluator for the output channels. *)
  let function immediateTransactionNetLoss (p : partyT) (args : transferFromPublicKeyAccountT) = 
    if not (transferFromPublicKeyAccountCorrect args) then 0 else
    let losses = fundsInvested args p in 
    let output = transactionOutput args in
    let potentialGains = 
      match output with 
      | None -> 0 
      | Some output' -> immediateAccountEvaluation output' p 
      end in
    let gains = if isFunder args p then potentialGains else 0 in 
    losses - gains
  
  (*We sum the immediate net losses over all well-formed transactions that we have signed*)
  let function immediateLossesInMoveOwnCoinsMsgs
    (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partyT) =
    let signedGoodArgs = getSignedGoodTransactions gamma sigs p in 
    sum (map (fun x -> immediateTransactionNetLoss p x) signedGoodArgs)
  
  (*Next, we compute the difference between what we (immediately) have on chain and what we can lose.*)
  let function immediatePartyExpectations
    (gamma : gammaStateT) (p :  partyT) (sigs : signatureFunctionalityT) = 
    immediateAmountOnChain gamma p - immediateLossesInMoveOwnCoinsMsgs gamma sigs p
    
  (*Computing the potential gains of the channel that we are tracing*)
  let function channelExpectations 
     (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
     (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT)  = 
  let funding = p.getTracedChannelId in 
  match computeVirtualContract funding gamma p.recordOwner currentTime sigs with 
    | Some channel -> worstCaseChannelResolution sigs channel p lastWoken msgs
    | None -> 0
  end
  
  (*The same as `channelExpectations`, but it takes a general `partySplitsAndRevocationsRecordGeneralT`*)
  let function channelExpectationsG
    (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  match makeStrict p with 
    | Some p' -> channelExpectations gamma sigs p' lastWoken msgs currentTime
    | None -> 0
  end 
  
  (*Finally we combine channelExpectations with the immediate party expectations *)
  let function partyExpectations2 (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
     (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  immediatePartyExpectations gamma p.recordOwner sigs + 
  channelExpectations gamma sigs p lastWoken msgs currentTime
  
  (*The same as `partyExpectations2`, but it takes a general `partySplitsAndRevocationsRecordGeneralT`*)
  let function partyExpectations2G (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
     (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  immediatePartyExpectations gamma p.recordOwnerG sigs + 
  channelExpectationsG gamma sigs p lastWoken msgs currentTime

  (*This finishes the alternative definition of the evaluator.*)

  (*We finish the module with some simple auxiliary functions*)
  
  (*Useful wrapper over channelExpectationsG, as we often will be interested in this surplus *)
  let function channelMinusBalanceOurA (p : partySplitsAndRevocationsRecordGeneralT) (sigs : signatureFunctionalityT) (gamma : gammaStateT) 
                                      (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) : amountT=
    channelExpectationsG gamma sigs p lastWoken msgs currentTime
    - p.balanceOurAGeneric
  
  (* Used in lemma `immediateLossesInMoveOwnCoinsMsgsWhenSigningTx`, to decide whether `immediateLossesInMoveOwnCoinsMsgs` changes *) 
  let function isArgsNewAndGood (gamma : gammaStateT) (args : transferFromPublicKeyAccountT) (p : partyT) (sigs : signatureFunctionalityT) =
    goodFunding gamma args &&
    not (isSigned_comp p (SignableTX args) sigs)
  
  let function isSignableTx (msg : signableT) = 
    match msg with
    | SignableTX _ -> true
    | _ -> false
    end
  
end (*Evaluator*)


module GammaInvariant 

  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  
  use list.Nth
  use list.Append
  
  use signaturesFunctionality.SignaturesFunctionality
  use export Gamma

  (*In this module, we define the invariant that gamma should always satisfy.*)
  (*We hope that the following predicates are self-explanatory*)
  
  predicate gammaNoDuplicatesUsed (gamma : gammaStateT) = 
    forall channel. num_occ channel gamma.allContracts <= 1 
    
  predicate gammaNoDuplicates (gamma : gammaStateT) = 
    forall channel. num_occ channel gamma.contractStatuses <= 1 
  
  predicate allChannelsFunded (gamma : gammaStateT) = 
    forall channel funding .
       member channel gamma.allContracts ->
       extractChannelId channel = Some funding -> 
       not (inputUnspent funding gamma)
       
  predicate disputeOpensFunded (gamma : gammaStateT) = 
    forall split. member (DisputeOpen split) gamma.allContracts -> 
      isSpent (Normal split.id) gamma
      
  predicate disputeOpensUniqueById (gamma : gammaStateT) = 
    forall split1 split2.
      member (DisputeOpen split1) gamma.allContracts-> 
      member (DisputeOpen split2) gamma.allContracts -> 
      split1.id = split2.id -> 
      split1 = split2
      
  predicate normalCorrectFunding (gamma : gammaStateT) = 
    forall funding . member (Normal funding) gamma.allContracts -> 
    funding.destination = Channel
    
  predicate disputeOpenCorrectFunding (gamma : gammaStateT) = 
    forall split . member (DisputeOpen split) gamma.allContracts -> 
    split.id.destination = Channel
    
  predicate gammaCurrentAreUsed (gamma : gammaStateT) = 
    forall status . member status gamma.contractStatuses ->
    member status gamma.allContracts
        
  predicate statusesAreGood (gamma : gammaStateT) = 
    forall status . member status gamma.allContracts -> 
    goodStatus status

  predicate publicKeyAccountsUniqueByIdT (gamma : gammaStateT) = 
    forall a1 a2 p1 p2 id.
      member (PublicKeyAccount a1 p1 id) gamma.allContracts -> 
      member (PublicKeyAccount a2 p2 id) gamma.allContracts -> 
      a1 = a2 /\ p1 = p2

  predicate normalChannelsUniqueByIdT (gamma : gammaStateT) = 
    forall args1 args2.
      member (Normal args1) gamma.allContracts -> 
      member (Normal args2) gamma.allContracts -> 
      args1.fundingId = args2.fundingId ->
      args1 = args2
          
  predicate gammaCoherent (gamma : gammaStateT) = 
    gammaNoDuplicates gamma /\
    gammaNoDuplicatesUsed gamma /\
    allChannelsFunded gamma /\ 
    disputeOpensFunded gamma /\
    disputeOpensUniqueById gamma /\
    normalCorrectFunding gamma /\
    disputeOpenCorrectFunding gamma /\
    gammaCurrentAreUsed gamma /\
    statusesAreGood gamma /\
    publicKeyAccountsUniqueByIdT gamma /\
    normalChannelsUniqueByIdT gamma

end


module GammaBasicLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)
  use basicTypes.BasicTypes
  use listLibrary.ListLibrary

  use signaturesFunctionality.SignaturesFunctionality
  
  use list.Append
  
  use Gamma
  use Evaluator
  use GammaInvariant

  (*Some simple auxiliary lemmas about the gamma.*)
  (*They are mainly useful in the proofs, but not necessarily of independent interest.*)

  val lemma gammaSpendContractSpends (gamma : gammaStateT) (toSpend : contractT) 
  requires {gammaCoherent gamma}
  requires {member toSpend gamma.activeContracts}
  ensures {isSpent toSpend.contractStatus (gammaSpendContract gamma toSpend)}
  
   
  val lemma insertContractStatuses (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT)
  ensures { (gammaInsertContracts gamma channels currentTime).contractStatuses = channels ++ gamma.contractStatuses}
  
  val lemma gammaInsertContractsInputSpentPreserved (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) (input : contractStatusT)
  requires {forall channel. member channel channels -> contractStatusFreshForGamma gamma channel}
  requires {isSpent input gamma }
  ensures  {isSpent input (gammaInsertContracts gamma channels currentTime)}
  
  val lemma gammaInsertContractsNotInputUnspentPreserved (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) (transaction : transferFromPublicKeyAccountT)
  requires {forall channel. member channel channels -> contractStatusFreshForGamma gamma channel}
  requires {not (inputUnspent transaction gamma)}
  ensures  {not (inputUnspent transaction (gammaInsertContracts gamma channels currentTime))}

  val lemma immediateTransactionNetLossNonNeg (args : transferFromPublicKeyAccountT) (p : partyT)
  requires {transferFromPublicKeyAccountCorrect args}
  ensures {immediateTransactionNetLoss p args >= 0}

  val lemma immediateLossesInMoveOwnCoinsMsgsNonNeg (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partyT) 
  requires {gammaCoherent gamma}
  ensures {immediateLossesInMoveOwnCoinsMsgs gamma sigs p >= 0}

  val lemma extractChannelByIdFromGammaCorrect (gamma : gammaStateT) (channelId : transferFromPublicKeyAccountT) (ch : contractT)
                                               (args : transferFromPublicKeyAccountT)
  requires {extractChannelByIdFromGamma gamma channelId = Some ch}
  requires {ch.contractStatus = Normal args}
  ensures  { args = channelId }

end (*GammaBasicLemmas*)


module ExistsFreshIdLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  
  use listLibrary.ListLibrary

  use Gamma
  use GammaInvariant

 (*A lemma that states that we can always find a fresh `idT` for any gamma. *)
  val lemma existsFreshId (gamma : gammaStateT)  (taken : list idT) 
  ensures {exists x. not (member x taken) /\ idFreshForGamma gamma x}

end (*ExistsFreshId*)


module GammaInvariantLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use list.Append

  use basicTypes.BasicTypes
  
  use listLibrary.ListLibrary
  use signaturesFunctionality.SignaturesFunctionality
  
  use GammaInvariant
  
  
  (*Some useful consequences of gamma invariant and the invariant preservation lemma (`gammaProcessCoherent`).*)
  
  val lemma channelsUniqueById (gamma : gammaStateT) (c1 c2 : contractStatusT) (args : transferFromPublicKeyAccountT)
  requires {gammaCoherent gamma}
  requires {member c1 gamma.contractStatuses} 
  requires {member c2 gamma.contractStatuses}
  requires {extractChannelId c1 = Some args } 
  requires {extractChannelId c2 = Some args }
  ensures {c1 = c2} 
  
  val lemma fullChannelsUniqueByContractStatus (gamma : gammaStateT) (c1 c2 : contractT)
  requires {gammaCoherent gamma}
  requires {member c1 gamma.activeContracts} 
  requires {member c2 gamma.activeContracts}
  requires {c1.contractStatus = c2.contractStatus} 
  ensures {c1 = c2}

  
  val lemma fullChannelUniqueByFounding (gamma : gammaStateT) (c1 c2 : contractT) (id : transferFromPublicKeyAccountT)
  requires { gammaCoherent gamma }
  requires {member c1 gamma.activeContracts } 
  requires {member c2 gamma.activeContracts } 
  requires {c1.contractStatus.extractChannelId = Some id } 
  requires {c2.contractStatus.extractChannelId = Some id }
  ensures  {c1 = c2}
    
  
  val lemma fullChannelsUnique (gamma : gammaStateT) (c1 : contractT)
  requires {gammaCoherent gamma}
  ensures {num_occ c1 gamma.activeContracts <= 1}
  
  val lemma msgFreshSoEvalOutFresh (msg : msgToGammaT) (g : gammaStateT)
  requires {gammaCoherent g}
  requires {checkFreshness msg g} 
  requires { not (isSpent (expectedContractStatus msg) g)}
  ensures  {forall x . member x (evalOut msg) -> contractStatusFreshForGamma g x }

  (*Invariant preservation lemma*)
  val lemma gammaProcessCoherent (gamma : gammaStateT) (msg : msgToGammaT)
                                 (sigState : signatureFunctionalityT) (time : timeT)
  requires { checkFreshness msg gamma}
  requires { gammaCoherent gamma}
  ensures  { gammaCoherent (gammaProcessMsgFreshFull gamma msg sigState time) }

  val lemma addMoneyFromVoidPreservesCoherent (gamma : gammaStateT) (id : idT) (amount : amountT) (party : partyT) (time : timeT)
  requires {gammaCoherent gamma}
  requires {amount >= 0}
  ensures  {gammaCoherent (addMoneyFromVoid gamma id amount party time)}
  
end (*GammaInvariantLemmas*)

module GammaProcessMsgLemmas 
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  
  use listLibrary.ListLibrary
  use signaturesFunctionality.SignaturesFunctionality
  use Gamma
  use GammaInvariant

  (*Some simple lemmas that describe the behavior of `gammaProcessMessage`*)
  val lemma ifOnChannelThanExtract (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT)
  requires {member channel gamma.activeContracts}
  requires {gammaCoherent gamma}
  requires {channel.contractStatus.extractChannelId = Some id}
  ensures {extractChannelByIdFromGamma gamma id = Some channel}

  val lemma ifNotOnChannelThenNoExtract (gamma : gammaStateT) (id : transferFromPublicKeyAccountT)
  requires {forall x. member x gamma.activeContracts -> x.contractStatus.extractChannelId <> Some id}
  ensures {extractChannelByIdFromGamma gamma id = None}
  

  val lemma gammaProcessMsgFreshSomeSoExistsMsgFull (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT)
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  ensures {exists x. member x g1.activeContracts /\ x.contractStatus = expectedContractStatus msg}
  
  
  val lemma gammaProcessMsgFreshSomeSpec (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractT)
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {member ch g1.activeContracts}
  requires {ch.contractStatus = expectedContractStatus msg}
  ensures {g2 = gammaProcessMsgDirect g1 msg time ch}

  val lemma gammaProcessMsgContractStatuses (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractStatusT)
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires { (member ch g1.contractStatuses /\ ch <> expectedContractStatus msg) \/ member ch (evalOut msg)}
  ensures {member ch g2.contractStatuses}

  val lemma gammaProcessMsgContractStatuses2 (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractStatusT)
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {member ch g2.contractStatuses}
  ensures { (member ch g1.contractStatuses /\ ch <> expectedContractStatus msg) \/ member ch (evalOut msg)}

  val lemma gammaProcessMsgActiveContracts (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractT)
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {(member ch g1.activeContracts /\ ch.contractStatus <> expectedContractStatus msg) \/ (ch.lastContractTransitionTime = time /\ member ch.contractStatus (evalOut msg))}
  ensures {member ch g2.activeContracts}

  val lemma gammaProcessMsgActiveContracts2 (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractT)
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {member ch g2.activeContracts}
  ensures {(member ch g1.activeContracts /\ ch.contractStatus <> expectedContractStatus msg) \/ (ch.lastContractTransitionTime = time /\ member ch.contractStatus (evalOut msg))}

end (*GammaProcessMsgLemmas*)


module EvaluatorBasicLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  use signaturesFunctionality.SignaturesFunctionality 

  (*Some simple auxiliary lemmas about the evaluator.*)
  (*They are mainly useful in the proofs, but not necessarily of independent interest.*)
  
  use list.Nth
  

  use Gamma
  use Evaluator
  use GammaInvariant

  val lemma expectedSplitResolutionTotalPositive (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT)
  requires{ goodSplit s } 
  ensures { expectedSplitResolutionTotal p revsSigned revsReceived s >= 0}
  ensures { expectedSplitResolutionWhenDispute p revsSigned revsReceived s.condOutput >= 0}
  
  val lemma expectedSplitResolutionOptionPositive (p : partyT) (id : transferFromPublicKeyAccountT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT)
  ensures { match expectedSplitResolutionOption p  id revsSigned revsReceived s with
            | None -> true
            | Some x -> x >= 0
          end }
  
  val lemma expectedSplitResolutionCompare2 (p : partyT) (revsSigned1 revsSigned2 : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT)
  requires { s.condOutput.amountCond >= 0 /\ s.amountUnCond >= 0 }
  requires { includedList revsReceived1 revsReceived2 }
  requires { includedList revsSigned2 revsSigned1 }
  ensures { expectedSplitResolutionTotal p revsSigned1 revsReceived1 s <= expectedSplitResolutionTotal p revsSigned2 revsReceived2 s }

  val lemma expectedSplitResolutionOptionCompare (p : partyT) (args : transferFromPublicKeyAccountT)  (revsSigned1 revsSigned2 : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT) (v1 v2 : int)
  requires { includedList revsReceived1 revsReceived2 }
  requires { includedList revsSigned2 revsSigned1 } 
  requires { expectedSplitResolutionOption p args revsSigned1 revsReceived1 s = Some v1 }
  requires { expectedSplitResolutionOption p args revsSigned2 revsReceived2 s = Some v2 } 
  ensures { v1 <= v2}
  
  
  val lemma expectedSplitResolutionCompare3 (p : partyT) (revsSigned1 revsSigned2 : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT)
  requires { (num_occ s.condOutput revsReceived1 > 0) <-> num_occ s.condOutput revsReceived2 > 0 }
  requires { (num_occ s.condOutput revsSigned1 > 0) <-> num_occ s.condOutput revsSigned2 > 0 }
  ensures { expectedSplitResolutionTotal p revsSigned1 revsReceived1 s = expectedSplitResolutionTotal p revsSigned2 revsReceived2 s }
  
  val lemma expectedSplitResolutionCompare4 (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT)
  requires { s.condOutput.amountCond >= 0 /\ s.amountUnCond >= 0 }
  requires { (num_occ s.condOutput revsReceived1 > 0) -> num_occ s.condOutput revsReceived2 > 0 }
  ensures { expectedSplitResolutionTotal p revsSigned revsReceived1 s <= expectedSplitResolutionTotal p revsSigned revsReceived2 s }
  
  
  val lemma expectedSplitResolutionBound2 (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT)
  requires { s.condOutput.amountCond > 0 /\ s.amountUnCond > 0 }
  ensures { expectedSplitResolutionTotal p revsSigned revsReceived s <= s.condOutput.amountCond + s.amountUnCond }
    
  val lemma expectedSplitResolutionOrderIndependent (p : partyT) (id : transferFromPublicKeyAccountT)
                                                    (revsSigned1 revsSigned2 : list conditionalOutputT) 
                                                    (revsReceived1 revsReceived2 : list conditionalOutputT) 
                                                    (s : splitT) 
  requires { (num_occ s.condOutput revsReceived1 > 0) <-> num_occ s.condOutput revsReceived2 > 0 }
  requires { (num_occ s.condOutput revsSigned1 > 0) <-> num_occ s.condOutput revsSigned2 > 0 }
  ensures { expectedSplitResolutionOption p id revsSigned1 revsReceived1 s =
            expectedSplitResolutionOption p id revsSigned2 revsReceived2 s }

    
  val lemma extractRevocationsReceivedSpec (p : partyT) (sigs : signatureFunctionalityT) (revs : list (signatureT, conditionalOutputT))
  ensures {forall s. (num_occ s (extractRevocationsReceived p sigs revs) > 0) <->
                    (exists sig.
                        num_occ (sig, s) revs > 0 /\
                        verify (other p) (SignableRevoke s) sig sigs)}

  val lemma correctAndEarlyEnoughRevokeMsgMonotone (sigs1 sigs2 : signatureFunctionalityT) (msplit : conditionalOutputT) (deadline : timeT) (msgAndTime : (msgToGammaT, timeT))
  requires { included sigs1 sigs2 }
  requires { correctAndEarlyEnoughRevokeMsg sigs1  msplit deadline msgAndTime}
  ensures { correctAndEarlyEnoughRevokeMsg sigs2  msplit deadline msgAndTime }

  val lemma immediateAccountEvaluationAlwaysPositive (channel : contractStatusT) (p : partyT)
  ensures { immediateAccountEvaluation channel p >= 0 }

  val lemma worstCaseChannelResolutionWhenSome (sigs : signatureFunctionalityT)
                                                                        (channel : contractT)
                                                                        (op : partySplitsAndRevocationsRecordGeneralT)
                                                                        (op' : partySplitsAndRevocationsRecordStrictT)
                                                                        (lastWoken : timeT) 
                                                                        (msgs : list (msgToGammaT, timeT))
  requires { makeStrict op = Some op' }
  ensures  { worstCaseChannelResolution sigs channel op' lastWoken msgs =
             worstCaseChannelResolutionFull sigs channel op lastWoken msgs }

  val lemma worstCaseChannelResolutionPositive (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordStrictT)
                                               (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) 
  requires {goodStatus channelFull.contractStatus}
  ensures { worstCaseChannelResolution sigs channelFull p lastWoken msgs  >= 0 }

  val lemma netLossNetLossFull (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
    (p' : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) 
  requires { p'.makeStrict = Some p } 
  ensures { transactionNetLoss args sigs p lastWoken msgs =transactionNetLossFull args sigs p' lastWoken msgs }

  val lemma worstCaseChannelResolutionLeq (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordStrictT)
                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (funding : transferFromPublicKeyAccountT)
  requires {transferFromPublicKeyAccountCorrect funding}
  requires {channelFull.contractStatus = Normal funding}
  ensures  {worstCaseChannelResolution sigs channelFull p lastWoken msgs <= funding.amount}
 
    
  val lemma transactionNetLossPositive (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
  ensures  { transactionNetLoss args sigs p lastWoken msgs >= 0 }
  
  val lemma virtualContractStatusGood (g : gammaStateT) (id : transferFromPublicKeyAccountT) (p : partyT) (t : timeT) (sigs : signatureFunctionalityT) (s : contractT)
  requires {gammaCoherent g}
  requires {computeVirtualContract id g p t sigs = Some s}
  ensures {goodStatus s.contractStatus}
   
  val lemma transactionNetLossPositiveFull (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
  ensures {transactionNetLossFull args sigs p lastWoken msgs >= 0}

  val lemma channelExpectationsNonneg 
   (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
   (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) 
  requires {gammaCoherent gamma}
  ensures {channelExpectations gamma sigs p lastWoken msgs currentTime >= 0}
  
  val lemma channelExpectationsGNonneg 
   (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
   (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT)
  requires {gammaCoherent gamma}
  ensures {channelExpectationsG gamma sigs p lastWoken msgs currentTime >= 0}

  val lemma ifNoExtractThenNoOnChannel (gamma : gammaStateT) (id : transferFromPublicKeyAccountT)
  requires { extractChannelByIdFromGamma gamma id = None } 
  ensures { forall x . member x gamma.contractStatuses -> x.extractChannelId <> Some id }
  
  val lemma ifExtractThenOnChannel (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) 
  requires {(extractChannelByIdFromGamma gamma id) = Some channel } 
  ensures { member channel gamma.activeContracts}
  
  val lemma ifExtractThenCorrectFunding (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT)
  requires {extractChannelByIdFromGamma gamma id = Some channel}
  ensures  {channel.contractStatus.extractChannelId = Some id } 
  
  val lemma ifExtractThenNotPublicKeyAccount (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) 
  requires {extractChannelByIdFromGamma gamma id = Some channel}
  ensures  {forall x y z . channel.contractStatus <> PublicKeyAccount x y z}

  val lemma partyExpectationsAdversarySigsMonotone (gamma : gammaStateT) (sigs1 sigs2 : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
  requires {gammaCoherent gamma}
  requires {signatureFunctionalityTransition p.recordOwnerG sigs1 sigs2} 
  ensures {partyExpectationsFull gamma sigs1 p lastWoken msgs <= partyExpectationsFull gamma sigs2 p lastWoken msgs}

  val lemma gammaCoherentSoImmediateAmountOnChainNonNeg (gamma : gammaStateT) (p : partyT) 
  requires {gammaCoherent gamma}
  ensures {immediateAmountOnChain gamma p >= 0}
 
end (*EvaluatorBasicLemmas*)

module EvaluatorOnChainForPartyLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  use basicTypes.Util
  (*use listLibrary.ListLibrary*)
  use signaturesFunctionality.SignaturesFunctionality 
  

  use Gamma
  use Evaluator

  (*Two lemmas that help us estimate how `immediateLossesInMoveOwnCoinsMsgs` changes when party signs a message*)

  val lemma immediateLossesInMoveOwnCoinsMsgsWhenSigningTx (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (args : transferFromPublicKeyAccountT) (gamma : gammaStateT)
  requires { sigs2 = (sign p (SignableTX args) sigs1).snd }
  ensures {
    immediateLossesInMoveOwnCoinsMsgs gamma sigs2 p = immediateLossesInMoveOwnCoinsMsgs gamma sigs1 p +
      if isArgsNewAndGood gamma args p sigs1 then 
        immediateTransactionNetLoss p args else 0 }
  
  val lemma immediateLossesInMoveOwnCoinsMsgsWhenSigningNotTx (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (msg : signableT) (gamma : gammaStateT)
  requires { sigs2 = (sign p msg sigs1).snd }
  requires { not isSignableTx msg }
  ensures { immediateLossesInMoveOwnCoinsMsgs gamma sigs2 p = immediateLossesInMoveOwnCoinsMsgs gamma sigs1 p }
  

end (* EvaluatorOnChainForPartyLemmas *)



module EvaluatorPreservationLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use Evaluator
  use basicTypes.BasicTypes
  use GammaInvariant
  use listLibrary.ListLibrary
  use signaturesFunctionality.SignaturesFunctionality

  (*One of the two key properties of the evaluator -- it states that when gamma
    processes a message, this never decreases the evaluator value for any party*)
  val lemma gammaProcessFreshMsgPreservesEvaluatorG (g : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (currentTime : timeT)
    (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentMsgDeadline : timeT) (newGamma : gammaStateT)
  requires { gammaCoherent g }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake }
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime }
  requires { gammaProcessMsg g msg sigState currentTime = CorrectGamma newGamma }
  ensures {
    partyExpectationsFull newGamma sigState p lastWoken msgs >= 
    partyExpectationsFull g        sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs)
  }

end (*EvaluatorPreservationLemmas*)



module EvaluatorAdditionalExportedLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use Evaluator
  use basicTypes.BasicTypes
  
  use GammaInvariant
  use listLibrary.ListLibrary
  use signaturesFunctionality.SignaturesFunctionality
  (* Additional simple facts about evaluator, used in later proves *)

  (*Three lemmas that say how the evaluator behaves when we apply some simple structural changes to the message queue.*)
  val lemma partyExpectationsMsgIdInvariant (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                           (lastWoken : timeT) (currentMsg : msgToGammaT) (currentMsgDeadline : timeT) (msgs : list (msgToGammaT, timeT))
                                           (id1 id2 : idT)
  ensures {partyExpectationsFull gamma sigs p lastWoken (Cons (currentMsg, currentMsgDeadline) msgs) = 
           partyExpectationsFull gamma sigs p lastWoken (Cons (replaceIdsInMsg currentMsg id1 id2, currentMsgDeadline) msgs)}

  val lemma partyExpectationsShuffleMsgsInvariant (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                  (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT))
  requires {listEq msgs1 msgs2}
  ensures {partyExpectationsFull gamma sigs p lastWoken msgs1 = partyExpectationsFull gamma sigs p lastWoken msgs2}

  val lemma partyExpectationsMsgMonotone (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                        (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT))
  requires {includedList msgs1 msgs2}
  ensures {partyExpectationsFull gamma sigs p lastWoken msgs1 <= partyExpectationsFull gamma sigs p lastWoken msgs2}


(*Simple lemma that states that adding new `PublicKeyAccounts` does not decrease the Evaluator value.*)
(* not in module `EvaluatorBasicLemmas` as used in explicitly in the experiment *)
val lemma gammaAddConsFromVoidPreservesEvaluator (gamma : gammaStateT) (sigState : signatureFunctionalityT) (time : timeT) (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (amount : amountT) (id : idT) (party : partyT)
requires {amount >= 0}
ensures {partyExpectationsFull (addMoneyFromVoid gamma id amount party time) sigState p lastWoken msgs >= partyExpectationsFull gamma sigState p lastWoken msgs}
 
end (* EvaluatorAdditionalExportedLemmas*)



module EvaluatorEquivalentStatementLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  
  use signaturesFunctionality.SignaturesFunctionality
  use Evaluator
  use GammaInvariant
  
  (*A lemma that states that the two formulations of the Evaluator are equal*)
  (*In a version for `partySplitsAndRevocationsRecordStrictT` and `partySplitsAndRevocationsRecordGeneralT`*)

  val lemma partyExpectationsEqual (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT)
  requires { gammaCoherent gamma }
  ensures {partyExpectations gamma sigs p lastWoken msgs = partyExpectations2 gamma sigs p lastWoken msgs currentTime}

  
  val lemma partyExpectationsEqualG (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (time : timeT)
  requires { gammaCoherent gamma }
  ensures {partyExpectationsFull gamma sigs p lastWoken msgs = partyExpectations2G gamma sigs p lastWoken msgs time } 
  

end (*EvaluatorEquivalentStatementLemmas*)

(* ============= PROOFS (don't read, verify ;) ) ==================*)

module SignatureFunctionalityBasicLemmasAndProofs
  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  
  use signaturesFunctionality.SignaturesFunctionality
  use basicTypes.Compare
  
  
  
  let lemma getSignedByMonotone (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) =
  requires { includedFor p sigs1 sigs2 }
  ensures { includedList (getSignedBy sigs1 p) (getSignedBy sigs2 p) }
    let lemma helper (x : signableT) =
    requires { (exists sig. verify p x sig sigs1) }
    ensures { (exists sig. verify p x sig sigs2) }
      let sig = any signatureT ensures { verify p x result sigs1 } in
      assert { verify p x sig sigs2 }
    in ()
  
  let lemma getSignedByMonotoneWeak (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) =
  requires { preserved p sigs1 sigs2 }
  ensures { includedList (getSignedBy sigs1 p) (getSignedBy sigs2 p) }
    let lemma helper (x : signableT) =
    requires { (exists sig. verify p x sig sigs1) }
    ensures { (exists sig. verify p x sig sigs2) }
      let _sig = any signatureT ensures { verify p x result sigs1 } in
      assert { (exists sig1:int. num_occ (p, x, sig1) (sigs1.storage) > 0) <->
               (exists sig1:int. num_occ (p, x, sig1) (sigs2.storage) > 0) };
      assert { (exists sig2. verify p x sig2 sigs2) }
    in ()
  
  let lemma preservedImplyGetSignedByListEq (s1 s2 : signatureFunctionalityT) (p : partyT) =
  requires { preserved p s1 s2 }
  ensures { listEq (getSignedBy s1 p) (getSignedBy s2 p) }
    getSignedByMonotoneWeak s1 s2 p;
    getSignedByMonotoneWeak s2 s1 p
  
  let lemma getSignedByAgreement (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) =
  requires { signatureFunctionalityTransition p sigs1 sigs2 }
  ensures { listEq (getSignedBy sigs1 p) (getSignedBy sigs2 p) }
    preservedImplyGetSignedByListEq sigs1 sigs2 p
  
  let lemma getSignedByWhenSign (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (m : signableT) =
  requires { sigs2 = (sign p m sigs1).snd }
  ensures { listEq (getSignedBy sigs2 p) (Cons m (getSignedBy sigs1 p)) }
    let (_, _) = sign p m sigs1 in 
    let lemma helper (x : signableT) =
    requires { (exists sig. verify p x sig sigs1) }
    ensures { (exists sig. verify p x sig sigs2) }
      let sig = any signatureT ensures { verify p x result sigs1 } in
      assert { verify p x sig sigs2 }
    in
    let lemma helper (x : signableT) =
    requires { (exists sig. verify p x sig sigs2) }
    ensures { (exists sig. verify p x sig sigs1) \/ x = m }
      if compareSignables x m then () else
      let sig = any signatureT ensures { verify p x result sigs2 } in
      assert { verify p x sig sigs1 }
    in
    let (newSig, newSigs) = sign p m sigs1 in
    assert { newSigs = sigs2 };
    assert { verify p m newSig newSigs };
    assert { forall x. (exists sig. verify p x sig sigs2) <-> ((exists sig. verify p x sig sigs1) \/ x = m) };
    assert { forall x. num_occ x (getSignedBy sigs2 p) > 0 <-> num_occ x (Cons m (getSignedBy sigs1 p)) > 0 }; (*crush5*)
    ()
  
  let lemma signatureFunctionalityTransitionWhenSign (p : partyT) (m : signableT)  (sigs : signatureFunctionalityT) =
  ensures { signatureFunctionalityTransition (other p) sigs (sign p m sigs).snd }
  let (_,  _) = sign p m sigs in 
  ()
  
end


module GammaBasicProofs : GammaBasicLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  use basicTypes.Compare
  
  use listLibrary.ListLibrary
  use SignatureFunctionalityBasicLemmasAndProofs
  use signaturesFunctionality.SignaturesFunctionality
  
  use list.Append
  
  use Gamma
  use GammaInvariant
  use Evaluator


  let lemma gammaSpendContractSpends (gamma : gammaStateT) (toSpend : contractT) = 
  requires {gammaCoherent gamma}
  requires {member toSpend gamma.activeContracts}
  ensures {isSpent toSpend.contractStatus (gammaSpendContract gamma toSpend)}
  let res = gammaSpendContract gamma toSpend in 
  let channel = toSpend.contractStatus in 
  assert { member channel gamma.contractStatuses};
  assert { member channel gamma.allContracts };
  assert { member channel res.allContracts };
  assert { res.activeContracts = removeOne toSpend gamma.activeContracts};
  assert { forall x . member x res.activeContracts -> x.contractStatus <> channel };
  assert { not (member channel res.contractStatuses)};
  ()
   
  let lemma insertContractStatuses 
    (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) =
  ensures { (gammaInsertContracts gamma channels currentTime).contractStatuses = channels ++ gamma.contractStatuses}
  assert { (gammaInsertContracts gamma channels currentTime).activeContracts =
            (map (fun (x:contractStatusT) -> contractT'mk x currentTime) channels) ++ gamma.activeContracts};
  assert { (gammaInsertContracts gamma channels currentTime).contractStatuses =
            map contractStatus ((map (fun (x:contractStatusT) -> contractT'mk x currentTime) channels) ++ gamma.activeContracts)};
  let _ = mapConcat contractStatus (map (fun (x:contractStatusT) -> contractT'mk x currentTime) channels) gamma.activeContracts in 
  assert { (gammaInsertContracts gamma channels currentTime).contractStatuses  = 
            (map contractStatus ((map (fun (x:contractStatusT) -> contractT'mk x currentTime) channels))) ++ 
            (map contractStatus gamma.activeContracts)};
  let _ = mapComposeAux (fun (x:contractStatusT) -> contractT'mk x currentTime) contractStatus channels in 
  assert {(map contractStatus ((map (fun (x:contractStatusT) -> contractT'mk x currentTime) channels)))  = 
          (map (fun (x:contractStatusT) -> contractStatus (contractT'mk x currentTime))) channels}; 
  assert {(fun (x:contractStatusT) -> contractStatus (contractT'mk x currentTime)) = fun x -> x };
  let _ = mapId channels in 
  ()
  
  let lemma gammaInsertContractsInputSpentPreserved
      (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) (input : contractStatusT) =
  requires {forall channel. member channel channels -> contractStatusFreshForGamma gamma channel}
  requires {isSpent input gamma }
  ensures  {isSpent input (gammaInsertContracts gamma channels currentTime)}
  ()
  
  let lemma gammaInsertContractsNotInputUnspentPreserved
      (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) (transaction : transferFromPublicKeyAccountT) =
  requires {forall channel. member channel channels -> contractStatusFreshForGamma gamma channel}
  requires {not (inputUnspent transaction gamma)}
  ensures  {not (inputUnspent transaction (gammaInsertContracts gamma channels currentTime))}
  ()

  let lemma immediateTransactionNetLossNonNeg (args : transferFromPublicKeyAccountT) (p : partyT) = 
  requires {transferFromPublicKeyAccountCorrect args}
  ensures {immediateTransactionNetLoss p args >= 0}
  match args.destination with 
  | Void -> assert {immediateTransactionNetLoss p args >= 0};
  | OtherParty -> assert {immediateTransactionNetLoss p args >= 0};
  | _ ->  assert {immediateTransactionNetLoss p args >= 0};
  end

  let lemma immediateLossesInMoveOwnCoinsMsgsNonNeg (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partyT) = 
  requires {gammaCoherent gamma}
  ensures {immediateLossesInMoveOwnCoinsMsgs gamma sigs p >= 0}
  ()

  let lemma extractChannelByIdFromGammaCorrect (gamma : gammaStateT) (channelId : transferFromPublicKeyAccountT) (ch : contractT)
                                               (args : transferFromPublicKeyAccountT) = 
  requires {extractChannelByIdFromGamma gamma channelId = Some ch}
  requires {ch.contractStatus = Normal args}
  ensures  { args = channelId }
  match filter (fun x -> (compareOption compareArgs) (x.contractStatus.extractChannelId) (Some channelId)) gamma.activeContracts with 
    | Nil ->
        assert {extractChannelByIdFromGamma gamma channelId = None}; 
        absurd 
    | Cons z _  ->
        assert {z.contractStatus.extractChannelId = Some channelId};
        assert {extractChannelByIdFromGamma gamma channelId = Some z}; (*unfold extractChannelByIdFromGamma*)
        assert {z = ch};
        assert {z.contractStatus = Normal args};
        assert { args = channelId };
               
  end
  
end (*GammaBasicProofs*)


module ExistsFreshIdProofs : ExistsFreshIdLemmas

  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  
  use listLibrary.ListLibrary
  use list.Append
  use Gamma
  use GammaInvariant

  (*A lemma that states that we can always find a fresh `idT` for any gamma. *)
  let lemma existsFreshId (gamma : gammaStateT)  (taken : list idT) =
  ensures {exists x. not (member x taken) /\ idFreshForGamma gamma x}
  let taken = gamma.usedIds ++ taken in 
  let fresh = any idT ensures {num_occ result taken = 0} in 
  assert {not (member fresh taken)};
  assert {idFreshForGamma gamma fresh} (*unfold idFreshForGamma*)

end (*ExistsFreshIdProofs*)

module EvaluatorBasicProofs : EvaluatorBasicLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  use basicTypes.Compare
  use signaturesFunctionality.SignaturesFunctionality 
  
  use list.Nth
  

  use Gamma
  use Evaluator
  use GammaInvariant
  use SignatureFunctionalityBasicLemmasAndProofs
  
  
  let lemma expectedSplitResolutionTotalPositive (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT)  = 
  requires{ goodSplit s } 
  ensures { expectedSplitResolutionTotal p revsSigned revsReceived s >= 0}
  ensures { expectedSplitResolutionWhenDispute p revsSigned revsReceived s.condOutput >= 0}
  assert {expectedSplitResolutionWhenDispute p revsSigned revsReceived s.condOutput >= 0};
  assert { unCondPayment p s >= 0}
  
  let lemma expectedSplitResolutionOptionPositive (p : partyT) (id : transferFromPublicKeyAccountT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT)  = 
  ensures { match expectedSplitResolutionOption p  id revsSigned revsReceived s with
            | None -> true
            | Some x -> x >= 0
          end }
  ()
  
  let lemma expectedSplitResolutionCompare2 (p : partyT) (revsSigned1 revsSigned2 : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT) =
  requires { s.condOutput.amountCond >= 0 /\ s.amountUnCond >= 0 }
  requires { includedList revsReceived1 revsReceived2 }
  requires { includedList revsSigned2 revsSigned1 }
  ensures { expectedSplitResolutionTotal p revsSigned1 revsReceived1 s <= expectedSplitResolutionTotal p revsSigned2 revsReceived2 s }
  ()

  let lemma expectedSplitResolutionOptionCompare (p : partyT) (args : transferFromPublicKeyAccountT)  (revsSigned1 revsSigned2 : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT) (v1 v2 : int) =
  requires { includedList revsReceived1 revsReceived2 }
  requires { includedList revsSigned2 revsSigned1 } 
  requires { expectedSplitResolutionOption p args revsSigned1 revsReceived1 s = Some v1 }
  requires { expectedSplitResolutionOption p args revsSigned2 revsReceived2 s = Some v2 } 
  ensures { v1 <= v2}
  ()
  
  let lemma expectedSplitResolutionCompare3 (p : partyT) (revsSigned1 revsSigned2 : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT) =
  requires { (num_occ s.condOutput revsReceived1 > 0) <-> num_occ s.condOutput revsReceived2 > 0 }
  requires { (num_occ s.condOutput revsSigned1 > 0) <-> num_occ s.condOutput revsSigned2 > 0 }
  ensures { expectedSplitResolutionTotal p revsSigned1 revsReceived1 s = expectedSplitResolutionTotal p revsSigned2 revsReceived2 s }
  ()
  
  let lemma expectedSplitResolutionCompare4 (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived1 revsReceived2 : list conditionalOutputT) (s : splitT) =
  requires { s.condOutput.amountCond >= 0 /\ s.amountUnCond >= 0 }
  requires { (num_occ s.condOutput revsReceived1 > 0) -> num_occ s.condOutput revsReceived2 > 0 }
  ensures { expectedSplitResolutionTotal p revsSigned revsReceived1 s <= expectedSplitResolutionTotal p revsSigned revsReceived2 s }
  ()
  
  
  let lemma expectedSplitResolutionBound2 (p : partyT) (revsSigned : list conditionalOutputT) (revsReceived : list conditionalOutputT) (s : splitT) =
  requires { s.condOutput.amountCond > 0 /\ s.amountUnCond > 0 }
  ensures { expectedSplitResolutionTotal p revsSigned revsReceived s <= s.condOutput.amountCond + s.amountUnCond }
  ()
    
  let lemma expectedSplitResolutionOrderIndependent (p : partyT) (id : transferFromPublicKeyAccountT)
                                                    (revsSigned1 revsSigned2 : list conditionalOutputT) 
                                                    (revsReceived1 revsReceived2 : list conditionalOutputT) 
                                                    (s : splitT) = 
  requires { (num_occ s.condOutput revsReceived1 > 0) <-> num_occ s.condOutput revsReceived2 > 0 }
  requires { (num_occ s.condOutput revsSigned1 > 0) <-> num_occ s.condOutput revsSigned2 > 0 }
  ensures { expectedSplitResolutionOption p id revsSigned1 revsReceived1 s =
            expectedSplitResolutionOption p id revsSigned2 revsReceived2 s }
  ()

    
  let lemma extractRevocationsReceivedSpec (p : partyT) (sigs : signatureFunctionalityT) (revs : list (signatureT, conditionalOutputT)) = 
  ensures{forall s. (num_occ s (extractRevocationsReceived p sigs revs) > 0) <->
                    (exists sig.
                        num_occ (sig, s) revs > 0 /\
                        verify (other p) (SignableRevoke s) sig sigs)}
  () (*split; In first branch: unfold extractRevocationsReceived in H *)   

  let lemma correctAndEarlyEnoughRevokeMsgMonotone (sigs1 sigs2 : signatureFunctionalityT) (msplit : conditionalOutputT) (deadline : timeT) (msgAndTime : (msgToGammaT, timeT)) =
  requires { included sigs1 sigs2 }
  requires { correctAndEarlyEnoughRevokeMsg sigs1  msplit deadline msgAndTime}
  ensures { correctAndEarlyEnoughRevokeMsg sigs2  msplit deadline msgAndTime }
  ()

  let lemma immediateAccountEvaluationAlwaysPositive (channel : contractStatusT) (p : partyT) =  
  ensures { immediateAccountEvaluation channel p >= 0 }
  ()

  let lemma worstCaseChannelResolutionWhenSome (sigs : signatureFunctionalityT)
                                                                       (channel : contractT)
                                                                       (op : partySplitsAndRevocationsRecordGeneralT)
                                                                       (op' : partySplitsAndRevocationsRecordStrictT)
                                                                       (lastWoken : timeT) 
                                                                       (msgs : list (msgToGammaT, timeT)) =
  requires { makeStrict op = Some op' }
  ensures  { worstCaseChannelResolution sigs channel op' lastWoken msgs =
             worstCaseChannelResolutionFull sigs channel op lastWoken msgs }
  ()

  let lemma worstCaseChannelResolutionPositive (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordStrictT)
                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires {goodStatus channelFull.contractStatus}
  ensures { worstCaseChannelResolution sigs channelFull p lastWoken msgs  >= 0 }
    let lastTransitionTime = any timeT in
    let _bestHsSplit = p.bestSplitReceived in 
    let channel = channelFull.contractStatus in 
      match channel with
      | Normal id ->
         let revsSigned : list conditionalOutputT = extractRevokedSplits (getSignedBy sigs (p.recordOwner)) in
         let splitsSigned : list splitT = extractSignedSplits (getSignedBy sigs (p.recordOwner)) in
         let revsReceived : list conditionalOutputT = extractRevocationsReceived (p.recordOwner) sigs (p.receivedRevocations) in
         assert { forall x. num_occ x
           (catMaybes (map (expectedSplitResolutionOption (p.recordOwner) id revsSigned revsReceived) splitsSigned)) > 0 -> x >= 0 
         }; (*finisher*)
         assert { worstCaseChannelResolution sigs {contractStatus = (Normal id); lastContractTransitionTime= lastTransitionTime} p lastWoken msgs >= 0}
      | DisputeOpen _split  ->
        assert { worstCaseChannelResolution sigs {contractStatus = channel; lastContractTransitionTime = lastTransitionTime} p lastWoken msgs >= 0} (*unfold worstCaseChannelResolution; crush*)
      | _ -> ()
      end
   
   let lemma netLossNetLossFull (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
    (p' : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires { p'.makeStrict = Some p } 
  ensures { transactionNetLoss args sigs p lastWoken msgs = transactionNetLossFull args sigs p' lastWoken msgs }
    ()


   let lemma worstCaseChannelResolutionLeq (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordStrictT)
                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (funding : transferFromPublicKeyAccountT) = 
  requires {transferFromPublicKeyAccountCorrect funding}
  requires {channelFull.contractStatus = Normal funding}
  ensures  {worstCaseChannelResolution sigs channelFull p lastWoken msgs <= funding.amount}
  let channel = channelFull.contractStatus in 
  let _lastTransitionTime = channelFull.lastContractTransitionTime in 
  let revsSigned  : list conditionalOutputT = extractRevokedSplits (getSignedBy sigs p.recordOwner) in
  let splitsSigned : list splitT = extractSignedSplits (getSignedBy sigs p.recordOwner) in
  let revsReceived : list conditionalOutputT =  extractRevocationsReceived p.recordOwner sigs p.receivedRevocations in
  let bestHsSplit = p.bestSplitReceived in 
  let hsResult = (expectedSplitResolutionTotal p.recordOwner revsSigned revsReceived) bestHsSplit.split in (*take minimum with what we wanted *)
  match channel with
    | Normal f ->
        if not compareParties bestHsSplit.split.condOutput.partyCond p.recordOwner then assert {worstCaseChannelResolution sigs channelFull p lastWoken msgs <= funding.amount} else
        if not verify (other bestHsSplit.split.condOutput.partyCond) (SignableSplit bestHsSplit.split) bestHsSplit.sigUnCond sigs then assert {worstCaseChannelResolution sigs channelFull p lastWoken msgs <= funding.amount} else (*wrong partyRecord *) (*OK*)
        if not checkApplicableSplitToNormal f bestHsSplit.split then assert {worstCaseChannelResolution sigs channelFull p lastWoken msgs <= funding.amount} else (* wrong partyRecord  and check of right id *) (*OK*)
        let _signedSplitsExpectedResolutions = catMaybes (map (expectedSplitResolutionOption p.recordOwner f revsSigned revsReceived) (splitsSigned)) in
        assert {checkApplicableSplitToNormal f (bestHsSplit.split)};
        assert {funding.totalAmount >= funding.amount};
        assert {bestHsSplit.split.condOutput.id = f};
        assert {bestHsSplit.split.condOutput.amountCond <= f.amount};
        assert { hsResult <= funding.amount};
        assert {worstCaseChannelResolution sigs channelFull p lastWoken msgs <= funding.amount}
    | _ -> absurd
  end

  let lemma transactionNetLossPositive (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
    ensures  { transactionNetLoss args sigs p lastWoken msgs >= 0 }
  let stmt = transactionNetLoss args sigs p lastWoken msgs >= 0 in 
  if not transferFromPublicKeyAccountCorrect args then assert {stmt} else
  if not isFunder args p.recordOwner then assert {stmt} else 
  let losses = fundsInvested args p.recordOwner in 
  let output = transactionOutput args in 
  let currentTime = any amountT in
  let potentialGains = 
    match output with 
      | None -> 0
      | Some output' -> 
        let outputFullChannel = {contractStatus = output'; lastContractTransitionTime = currentTime} in 
        worstCaseChannelResolution sigs outputFullChannel p lastWoken msgs
    end in 
  let gains = potentialGains in 
  match output with 
    | Some (PublicKeyAccount _amount _owner _id) -> assert { losses >= gains }
    | Some (Normal funding) ->
      assert {funding = args};
      let outputFullChannel = {contractStatus = (Normal funding); lastContractTransitionTime = currentTime} in
      worstCaseChannelResolutionLeq sigs outputFullChannel p lastWoken msgs funding;
      assert { losses >= gains }
    | None -> assert {losses >= gains}
    | _ -> absurd
  end
  
  let function compareOptionArgs x y = compareOption compareArgs x y
  
  let lemma virtualContractStatusGood (g : gammaStateT) (id : transferFromPublicKeyAccountT) (p : partyT) (t : timeT) (sigs : signatureFunctionalityT) (s : contractT) = 
  requires {gammaCoherent g}
  requires {computeVirtualContract id g p t sigs = Some s}
  ensures {goodStatus s.contractStatus}
  match computeVirtualContract id g p t sigs with 
  | None -> absurd 
  | Some ch -> 
    assert {id.destination = Channel};
    let filtered = filter (fun x2 -> compareOptionArgs (extractChannelId (x2.contractStatus)) (Some id)) (g.activeContracts) in 
    match filtered with 
      | Nil ->
          assert {extractChannelByIdFromGamma g id = None};
          assert {goodStatus ch.contractStatus};
      | Cons x _ ->
          assert {extractChannelByIdFromGamma g id = Some x}; (*unfold extractChannelByIdFromGamma*)
          assert {member x filtered};
          assert {member x g.activeContracts};
          assert {goodStatus x.contractStatus}; 
          assert {goodStatus ch.contractStatus};
    end
  end

  let lemma transactionNetLossPositiveFull (args : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) p (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  ensures {transactionNetLossFull args sigs p lastWoken msgs >= 0}
  match (makeStrict p) with 
    | None -> assert {transactionNetLossFull args sigs p lastWoken msgs >= 0}
    | Some _ -> assert {transactionNetLossFull args sigs p lastWoken msgs >= 0}
  end
  

  let lemma channelExpectationsNonneg 
   (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT)
   (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  requires {gammaCoherent gamma}
  ensures {channelExpectations gamma sigs p lastWoken msgs currentTime >= 0}
  match computeVirtualContract p.getTracedChannelId gamma p.recordOwner currentTime sigs with 
    | Some channel ->
      assert {goodStatus channel.contractStatus};
      assert {worstCaseChannelResolution sigs channel p lastWoken msgs >= 0};
      assert {channelExpectations gamma sigs p lastWoken msgs currentTime >= 0}
    | _ -> assert {channelExpectations gamma sigs p lastWoken msgs currentTime >= 0}
  end
  
  let lemma channelExpectationsGNonneg 
   (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT)
   (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  requires {gammaCoherent gamma}
  ensures {channelExpectationsG gamma sigs p lastWoken msgs currentTime >= 0} 
  match (makeStrict p) with 
    | None -> assert {channelExpectationsG gamma sigs p lastWoken msgs currentTime >= 0} 
    | Some _ -> assert {channelExpectationsG gamma sigs p lastWoken msgs currentTime >= 0} 
  end

  let lemma ifNoExtractThenNoOnChannel (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) =
  requires { extractChannelByIdFromGamma gamma id = None } 
  ensures { forall x . member x gamma.contractStatuses -> x.extractChannelId <> Some id }
  match filter (fun x -> compareOptionArgs (extractChannelId (x.contractStatus)) (Some id)) (gamma.activeContracts)  with 
    | Cons _ _ -> assert {extractChannelByIdFromGamma gamma id <> None}; (*unfold extractChannelByIdFromGamma*)
                  absurd
    | Nil -> assert {forall  x . member x gamma.activeContracts -> x.contractStatus.extractChannelId <> Some id};
             let _ = mapInversion contractStatus (fun x -> not (compareOptionArgs x.contractStatus.extractChannelId  (Some id))) 
                                                (fun x -> not (compareOptionArgs x.extractChannelId  (Some id))) 
                                                 gamma.activeContracts in 
             assert { forall x . member x gamma.contractStatuses -> x.extractChannelId <> Some id } 
  end
  
  let lemma ifExtractThenOnChannel (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) = 
  requires {(extractChannelByIdFromGamma gamma id) = Some channel } 
  ensures { member channel gamma.activeContracts}
  match filter (fun x -> compareOptionArgs (x.contractStatus.extractChannelId) (Some id)) gamma.activeContracts  with 
    | Cons x _ -> assert {x = channel}; (*unfold extractChannelByIdFromGamma in Requires; finisher*)
                  assert { member channel gamma.activeContracts}
    | Nil -> absurd
  end
  
  let lemma ifExtractThenCorrectFunding (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) = 
  requires {extractChannelByIdFromGamma gamma id = Some channel}
  ensures  {channel.contractStatus.extractChannelId = Some id } 
  match filter (hasGivenChannelId id) gamma.activeContracts  with 
    | Cons x _ -> assert { x.contractStatus.extractChannelId = Some id };
                  assert {extractChannelByIdFromGamma gamma id = Some channel};
                  assert {Some channel = Some x}; (*unfold extractChannelByIdFromGamma in Assert; rewrite H in Assert*)
                  assert { channel = x };
                  assert { channel.contractStatus.extractChannelId = Some id  }
    | Nil -> absurd
  end
  
  
  let lemma ifExtractThenNotPublicKeyAccount (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) = 
  requires {extractChannelByIdFromGamma gamma id = Some channel}
  ensures  {forall x y z . channel.contractStatus <> PublicKeyAccount x y z}
  ()

  let lemma worstCaseChannelResolutionGeneraAdversarySigsMonotone (sigs1 sigs2 : signatureFunctionalityT) (channel : contractT) (p : partySplitsAndRevocationsRecordStrictT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires { goodStatus channel.contractStatus}
  requires { signatureFunctionalityTransition p.recordOwner sigs1 sigs2 }
  ensures  { worstCaseChannelResolution sigs1 channel p lastWoken msgs <= worstCaseChannelResolution sigs2 channel p lastWoken msgs }
  let st = worstCaseChannelResolution sigs1 channel p lastWoken msgs <= worstCaseChannelResolution sigs2 channel p lastWoken msgs in 
  let signed1 = (getSignedBy sigs1 (p.recordOwner)) in 
  let signed2 = (getSignedBy sigs2 (p.recordOwner)) in 
  assert {listEq signed1 signed2};
  let revokedSplits1 = extractRevokedSplits signed1 in 
  let revokedSplits2 = extractRevokedSplits signed2 in 
  assert {listEq revokedSplits1 revokedSplits2};
  let revocationsReceived1 = extractRevocationsReceived p.recordOwner sigs1 p.receivedRevocations in 
  let revocationsReceived2 = extractRevocationsReceived p.recordOwner sigs2 p.receivedRevocations in 
  assert {forall rev.   verify (other (p.recordOwner)) (SignableRevoke (snd rev)) (fst rev) sigs1 -> 
                        verify (other (p.recordOwner)) (SignableRevoke (snd rev)) (fst rev) sigs1};
  assert {includedList revocationsReceived1 revocationsReceived2};
  let signedSplits1 = extractSignedSplits signed1 in 
  let signedSplits2 = extractSignedSplits signed2 in 
  assert {listEq signedSplits1 signedSplits2};
  assert {worstCaseChannelResolution sigs1 channel p lastWoken msgs >= 0};
  assert {worstCaseChannelResolution sigs2 channel p lastWoken msgs >= 0};
  match channel.contractStatus with 
  | Normal args ->
    if not checkApplicableSplitToNormal args p.bestSplitReceived.split then assert {st} else (
    let b1 =  expectedSplitResolutionTotal p.recordOwner revokedSplits1 revocationsReceived1 (p.bestSplitReceived.split) in 
    let b2 =  expectedSplitResolutionTotal p.recordOwner revokedSplits2 revocationsReceived2 (p.bestSplitReceived.split) in
    let function f1 = fun x -> expectedSplitResolutionOption (p.recordOwner) args revokedSplits1 revocationsReceived1 x in 
    let function f2 = fun x -> expectedSplitResolutionOption (p.recordOwner) args revokedSplits2 revocationsReceived2 x in 
    (*minListAuxMap b1 b2 f1 f2 signed1;*)
    minListAuxOrderIndependent b2 (catMaybes (map f2 signedSplits1)) (catMaybes (map f2 signedSplits2)); 
    assert {includedList signedSplits1 signedSplits2};
    assert {includedList revokedSplits2 revokedSplits1};
    assert {includedList revocationsReceived1 revocationsReceived2};
    minListAuxCatMaybesMap b1 b2 f1 f2 signedSplits1;
    assert {minListAux b1 (catMaybes (map f1 signedSplits1)) <= minListAux b2 (catMaybes (map f2 signedSplits1))};
    assert {minListAux b2 (catMaybes (map f2 signedSplits1)) = minListAux b2 (catMaybes (map f2 signedSplits2))};
    assert {st})
  | DisputeOpen _s -> assert {st}; (*unfold worstCaseChannelResolution; rewrite H; finisher*)
  | PublicKeyAccount _ _ _ -> assert {st};
  end
  
  let lemma worstCaseChannelResolutionFullGeneraAdversarySigsMonotone (sigs1 sigs2 : signatureFunctionalityT) (channel : contractT) (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires { goodStatus channel.contractStatus }
  requires { signatureFunctionalityTransition p.recordOwnerG sigs1 sigs2 }
  ensures  { worstCaseChannelResolutionFull sigs1 channel p lastWoken msgs <= worstCaseChannelResolutionFull sigs2 channel p lastWoken msgs }
  ()
  
  
  
  let lemma getSignedGoodTransactionsMonotone (gamma : gammaStateT) (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) =
  requires { signatureFunctionalityTransition p sigs1 sigs2 }
  ensures { listStrongEq (getSignedGoodTransactions gamma sigs1 p) (getSignedGoodTransactions gamma sigs2 p) }
    assert { listEq (getSignedBy sigs1 p) (getSignedBy sigs2 p)};
    catMaybesMapListEq (getSignedBy sigs1 p) (getSignedBy sigs2 p) (fun y -> extractArgsFromSignableTX y);
    assert { listEq
      (filter (fun (y1:transferFromPublicKeyAccountT) -> goodFunding gamma y1)
      (catMaybes (map extractArgsFromSignableTX
        (getSignedBy sigs1 p))))
    (filter (fun (y1:transferFromPublicKeyAccountT) -> goodFunding gamma y1)
     (catMaybes (map extractArgsFromSignableTX
       (getSignedBy sigs2 p)))) };
    assert { listStrongEq (getSignedGoodTransactions gamma sigs1 p) (getSignedGoodTransactions gamma sigs2 p)} (*unfold getSignedGoodTransactions*)
  
  
  
  let lemma partyExpectationsAdversarySigsMonotone (gamma : gammaStateT) (sigs1 sigs2 : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires {gammaCoherent gamma}
  requires { signatureFunctionalityTransition p.recordOwnerG sigs1 sigs2 } 
  ensures { partyExpectationsFull gamma sigs1 p lastWoken msgs <= partyExpectationsFull gamma sigs2 p lastWoken msgs } 
  assert {forall x . member x gamma.activeContracts -> goodStatus x.contractStatus};
  (* changed name, check proof *)
  mapSumMonotoneOnF (fun x -> worstCaseChannelResolutionFull sigs2 x p lastWoken msgs) (fun x -> worstCaseChannelResolutionFull sigs1 x p lastWoken msgs) gamma.activeContracts;
  assert { moneyInChannelsFull gamma sigs1 p lastWoken msgs <= moneyInChannelsFull gamma sigs2 p lastWoken msgs };
  getSignedGoodTransactionsMonotone gamma sigs1 sigs1 (p.recordOwnerG);
  let signed1 = (getSignedGoodTransactions gamma sigs1 (p.recordOwnerG)) in 
  let signed2 = (getSignedGoodTransactions gamma sigs2 (p.recordOwnerG)) in
  assert {listStrongEq signed1 signed2 };
  assert { forall x y.
                    x.transactionOutput = Some y -> 
                    transferFromPublicKeyAccountCorrect x -> 
                    (fundsInvested x (p.recordOwnerG) - worstCaseChannelResolutionFull sigs1 (contractT'mk y 0) p lastWoken msgs) >= 
                    (fundsInvested x (p.recordOwnerG) - worstCaseChannelResolutionFull sigs2 (contractT'mk y 0) p lastWoken msgs)};
  assert {forall x. transactionNetLossFull x sigs1 p lastWoken msgs >= transactionNetLossFull x sigs2 p lastWoken msgs};
  let l1 = map (fun x -> transactionNetLossFull x sigs1 p lastWoken msgs) signed1 in 
  let l2 = map (fun x -> transactionNetLossFull x sigs1 p lastWoken msgs) signed2 in 
  let l3 = map (fun x -> transactionNetLossFull x sigs2 p lastWoken msgs) signed2 in 
  sumIsOrderIndependent l1 l2;
  assert {sum l2 >= sum l3};
  assert { lossesInMoveOwnCoinsMsgsFull gamma sigs1 p lastWoken msgs >= lossesInMoveOwnCoinsMsgsFull gamma sigs2 p lastWoken msgs}
  (*^ unfold lossesInMoveOwnCoinsMsgsFull*)
  
  let lemma gammaCoherentSoImmediateAmountOnChainNonNeg (gamma : gammaStateT) (p : partyT) = 
  requires {gammaCoherent gamma}
  ensures {immediateAmountOnChain gamma p >= 0}
  assert {statusesAreGood gamma};
  assert {forall x. member x gamma.activeContracts -> member x.contractStatus gamma.allContracts};
  assert {forall x. member x gamma.activeContracts ->  immediateAccountEvaluation (x.contractStatus) p >= 0}; (*unfold immediateAccountEvaluation*)
  ()

end (*EvaluatorBasicProofs*)

module EvaluatorOnChainForPartyProofs : EvaluatorOnChainForPartyLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  
  use listLibrary.ListLibrary
  use basicTypes.Compare
  use signaturesFunctionality.SignaturesFunctionality
  use SignatureFunctionalityBasicLemmasAndProofs
  use Evaluator
  
  let lemma noTxNoExtract (msg : signableT) =
  requires { not isSignableTx msg }
  ensures { extractArgsFromSignableTX msg = None }
    match msg with
    | SignableTX _arg ->
      absurd
    | _ -> assert { extractArgsFromSignableTX msg = None }
    end
  
  let lemma getSignedGoodTransactionsWhenSigningNotTx (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (msg : signableT) (gamma : gammaStateT) =
  requires { sigs2 = (sign p msg sigs1).snd }
  requires { not isSignableTx msg }
  ensures { listStrongEq (getSignedGoodTransactions gamma sigs1 p) (getSignedGoodTransactions gamma sigs2 p) }
      getSignedByWhenSign sigs1 sigs2 p msg;
    assert { listEq (getSignedBy sigs2 p) (Cons msg (getSignedBy sigs1 p)) };
    catMaybesMapListEq (getSignedBy sigs2 p) (Cons msg (getSignedBy sigs1 p)) extractArgsFromSignableTX;
    assert { extractArgsFromSignableTX msg = None };
    assert { (map extractArgsFromSignableTX (Cons msg (getSignedBy sigs1 p))) = Cons None (map extractArgsFromSignableTX (getSignedBy sigs1 p)) };
    assert { catMaybes (map extractArgsFromSignableTX (Cons msg (getSignedBy sigs1 p))) = catMaybes (map extractArgsFromSignableTX (getSignedBy sigs1 p)) };
    let l1 = filter (goodFunding gamma)
             (catMaybes (map extractArgsFromSignableTX
             (getSignedBy sigs1 p))) in
    let l2 = filter (goodFunding gamma)
             (catMaybes (map extractArgsFromSignableTX
             (getSignedBy sigs2 p))) in
    assert { listEq l1 l2 };
    assert { listStrongEq (makeUnique_comp compareArgs l1) (makeUnique_comp compareArgs l2) };
    assert { listStrongEq (getSignedGoodTransactions gamma sigs1 p) (getSignedGoodTransactions gamma sigs2 p)}
  
  
  (*listLibrary type function *)
  let ghost function numOccAsFilter (l : list 'a) (x : 'a) =
  ensures { num_occ x l = length (filter (fun y -> y = x) l) }
    mapSpecNum (fun x -> x) l x;
    mapId l;
    assert { num_occ x l = length (filter (fun y -> y = x) l) }
  
  let ghost function mapInjective (f : 'a -> 'b) (l : list 'a) (x : 'a) =
  requires { forall y. f x = f y -> x = y }
  ensures { num_occ (f x) (map f l) = num_occ x l }
    assert { forall xp. (counterImg f (f x) xp) = (xp = x) };
    mapSpecNum f l (f x);
    numOccAsFilter l x;
    assert { num_occ (f x) (map f l) = num_occ x l}
  
  let lemma getSignedGoodTransactionsWhenSigningTx (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (args : transferFromPublicKeyAccountT) (gamma : gammaStateT) =
  requires { sigs2 = (sign p (SignableTX args) sigs1).snd }
  ensures { 
  match isArgsNewAndGood gamma args p sigs1 with
  | True -> 
    listStrongEq (getSignedGoodTransactions gamma sigs2 p) (Cons args (getSignedGoodTransactions gamma sigs1 p))
  | False ->
    listStrongEq (getSignedGoodTransactions gamma sigs2 p) (getSignedGoodTransactions gamma sigs1 p) 
  end}
    let msg = SignableTX args in
      getSignedByWhenSign sigs1 sigs2 p msg;
    assert { listEq (getSignedBy sigs2 p) (Cons msg (getSignedBy sigs1 p)) };
    catMaybesMapListEq (getSignedBy sigs2 p) (Cons msg (getSignedBy sigs1 p)) extractArgsFromSignableTX;
    assert { extractArgsFromSignableTX msg = Some args };
    assert { (map extractArgsFromSignableTX (Cons msg (getSignedBy sigs1 p))) = Cons (Some args) (map extractArgsFromSignableTX (getSignedBy sigs1 p)) };
    assert { catMaybes (map extractArgsFromSignableTX (Cons msg (getSignedBy sigs1 p))) =
             Cons args (catMaybes (map extractArgsFromSignableTX (getSignedBy sigs1 p))) };
    let l1 = filter (goodFunding gamma)
               (catMaybes (map extractArgsFromSignableTX
               (getSignedBy sigs1 p))) in
    let l2 = filter (goodFunding gamma)
             (catMaybes (map extractArgsFromSignableTX
             (getSignedBy sigs2 p))) in
    assert { forall x. makeUnique_comp compareArgs x = makeUnique x };
    assert { getSignedGoodTransactions gamma sigs1 p = makeUnique l1 };
    assert { getSignedGoodTransactions gamma sigs2 p = makeUnique l2 };
    if not (goodFunding gamma args) then (
      assert { listEq l1 l2 };
      assert { listEq (makeUnique_comp compareArgs l1) (makeUnique_comp compareArgs l2) };
      assert { listStrongEq (getSignedGoodTransactions gamma sigs1 p) (getSignedGoodTransactions gamma sigs2 p) };
    ) else (
      assert { listEq l2 (Cons args l1) };
      assert { listStrongEq (makeUnique l2) (makeUnique (Cons args l1)) };
          assert { num_occ args l1 = num_occ args (catMaybes (map extractArgsFromSignableTX (getSignedBy sigs1 p))) };
          assert { num_occ args l1 = num_occ (Some args) (map extractArgsFromSignableTX (getSignedBy sigs1 p)) };
          mapInjective extractArgsFromSignableTX (getSignedBy sigs1 p) (SignableTX args);
        assert { num_occ args l1 = num_occ (SignableTX args) (getSignedBy sigs1 p) };
        assert { num_occ args l1 > 0 <-> isSigned p (SignableTX args) sigs1 };
      assert { isSigned p (SignableTX args) sigs1 <-> num_occ args l1 > 0 };
      if isSigned p (SignableTX args) sigs1 then (
        assert { listStrongEq (makeUnique (Cons args l1)) (makeUnique l1) };
        assert { listStrongEq (makeUnique l2) (makeUnique l1) };
        assert { listStrongEq (getSignedGoodTransactions gamma sigs1 p) (getSignedGoodTransactions gamma sigs2 p) }; 
      ) else (
        assert { listStrongEq (makeUnique (Cons args l1)) (Cons args (makeUnique l1)) };
        assert { listStrongEq (makeUnique l2) (Cons args (makeUnique l1)) };
        assert { listStrongEq (getSignedGoodTransactions gamma sigs2 p) (Cons args (getSignedGoodTransactions gamma sigs1 p)) };
      )
    )
  
  let lemma immediateLossesInMoveOwnCoinsMsgsWhenSigningTx (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (args : transferFromPublicKeyAccountT) (gamma : gammaStateT) =
  requires { sigs2 = (sign p (SignableTX args) sigs1).snd }
  ensures {
    immediateLossesInMoveOwnCoinsMsgs gamma sigs2 p = immediateLossesInMoveOwnCoinsMsgs gamma sigs1 p +
      if isArgsNewAndGood gamma args p sigs1 then 
        immediateTransactionNetLoss p args else 0 }
    if not isArgsNewAndGood gamma args p sigs1 then (
      assert { listStrongEq (getSignedGoodTransactions gamma sigs2 p) (getSignedGoodTransactions gamma sigs1 p) };
      assert { immediateLossesInMoveOwnCoinsMsgs gamma sigs2 p = immediateLossesInMoveOwnCoinsMsgs gamma sigs1 p }
    ) else (
      let l2 = getSignedGoodTransactions gamma sigs2 p in
      let l1 = getSignedGoodTransactions gamma sigs1 p in
      assert { listStrongEq l2 (Cons args l1) };
      let function f x = immediateTransactionNetLoss p x in
      assert { listStrongEq (map f l2) (Cons (f args) (map f l1)) };
      assert { immediateLossesInMoveOwnCoinsMsgs gamma sigs2 p = immediateLossesInMoveOwnCoinsMsgs gamma sigs1 p + immediateTransactionNetLoss p args }
    )
  
  let lemma immediateLossesInMoveOwnCoinsMsgsWhenSigningNotTx (sigs1 sigs2 : signatureFunctionalityT) (p : partyT) (msg : signableT) (gamma : gammaStateT) =
  requires { sigs2 = (sign p msg sigs1).snd }
  requires { not isSignableTx msg }
  ensures { immediateLossesInMoveOwnCoinsMsgs gamma sigs2 p = immediateLossesInMoveOwnCoinsMsgs gamma sigs1 p }
    ()
  
end (*EvaluatorOnChainForPartyProofs*)
        
module GammaInvariantProofs : GammaInvariantLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use list.Append

  use basicTypes.BasicTypes
  use basicTypes.Compare
  
  use listLibrary.ListLibrary
  use signaturesFunctionality.SignaturesFunctionality
  
  use GammaInvariant
  use GammaBasicLemmas
  
  
  (*We start with some useful implications of gamma invariant*)
  
  let lemma channelsUniqueById (gamma : gammaStateT) (c1 c2 : contractStatusT) (args : transferFromPublicKeyAccountT) = 
  requires {gammaCoherent gamma}
  requires {member c1 gamma.contractStatuses} 
  requires {member c2 gamma.contractStatuses}
  requires {extractChannelId c1 = Some args } 
  requires {extractChannelId c2 = Some args }
  ensures {c1 = c2} 
  match c1, c2 with 
    |  PublicKeyAccount _ _ _ , _  
    |  _, PublicKeyAccount _ _ _ -> absurd 
    | Normal _, Normal _ -> assert {c1 = c2};
    | DisputeOpen _s1, DisputeOpen _s2 -> assert {c1 = c2};
    | DisputeOpen _, Normal a
    | Normal a, DisputeOpen _ -> assert {isSpent (Normal a) gamma}; absurd
    | _ -> absurd
  end
  
  let lemma fullChannelsUniqueByContractStatus (gamma : gammaStateT) (c1 c2 : contractT) = 
  requires {gammaCoherent gamma}
  requires {member c1 gamma.activeContracts} 
  requires {member c2 gamma.activeContracts}
  requires {c1.contractStatus = c2.contractStatus} 
  ensures {c1 = c2}
  let channel = c1.contractStatus in
  assert {member c1 (filter (counterImg contractStatus channel) gamma.activeContracts )};
  assert {member c2 (filter (counterImg contractStatus channel) gamma.activeContracts )};
  assert { c1 <> c2 -> length (filter (counterImg contractStatus channel) gamma.activeContracts) >= 2};
  assert {c1 = c2}
  
  let lemma fullChannelUniqueByFounding (gamma : gammaStateT) (c1 c2 : contractT) (id : transferFromPublicKeyAccountT) = 
  requires { gammaCoherent gamma }
  requires {member c1 gamma.activeContracts } 
  requires {member c2 gamma.activeContracts } 
  requires {c1.contractStatus.extractChannelId = Some id } 
  requires {c2.contractStatus.extractChannelId = Some id }
  ensures  {c1 = c2}
  let _ = channelsUniqueById gamma c1.contractStatus c2.contractStatus id in 
  let _ = fullChannelsUniqueByContractStatus gamma c1 c2 in 
  ()
    
  
  let lemma fullChannelsUnique (gamma : gammaStateT) (c1 : contractT) = 
  requires {gammaCoherent gamma}
  ensures {num_occ c1 gamma.activeContracts <= 1}
  if num_occ c1 gamma.activeContracts > 1 then 
    ( let _ = mapNumOccGeq contractStatus  gamma.activeContracts c1 2 in 
     assert { num_occ c1.contractStatus gamma.contractStatuses > 1 };
     assert { length (filter (fun x -> x.contractStatus = c1.contractStatus) gamma.activeContracts) > 1};   
    absurd) 
  else 
  assert { num_occ c1 gamma.activeContracts <= 1}
 
  (*Now, let us prove that gamma process message preserves the gamma invariant, we do this with sublemmas *)
  
  
  let lemma gammaSpendContractInvariant (gamma : gammaStateT) (toSpend : contractT) =
  requires { member toSpend gamma.activeContracts } 
  requires { gammaCoherent gamma }
  ensures { gammaCoherent (gammaSpendContract gamma toSpend)}
  let res = gammaSpendContract gamma toSpend in 
  assert {res.activeContracts = removeOne toSpend gamma.activeContracts};
  assert { gammaNoDuplicates res };
  assert { disputeOpensFunded res };
  assert { allChannelsFunded res }; (*unfold allChannelsFunded*)
  assert { disputeOpensUniqueById res }; (*crush*)
  assert { normalCorrectFunding res }; (*crush*)
  assert { disputeOpenCorrectFunding res }; (*crush*)
  assert { gammaCurrentAreUsed res };
  ()
  
  let lemma gammaInsertContractsDisputeOpensFundedEasy (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall split . not (member (DisputeOpen split) channels) } 
  requires { forall channel . member channel channels -> contractStatusFreshForGamma gamma channel}
  ensures  { disputeOpensFunded (gammaInsertContracts gamma channels currentTime) } 
  let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { disputeOpensFunded gamma};
  assert {forall split. member (DisputeOpen split) gamma.contractStatuses -> isSpent (Normal split.id) gamma };
  (*^ This is unfolded dispute opens funded *)
  assert { forall x . (member x (res.contractStatuses)) -> member x channels \/ member x gamma.contractStatuses}
  
  let lemma gammaInsertContractsDisputeOpensFundedHard (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall channel . member channel channels -> contractStatusFreshForGamma gamma channel}
  requires { forall split . member (DisputeOpen split) channels -> isSpent (Normal split.id) gamma } 
  ensures  { disputeOpensFunded (gammaInsertContracts gamma channels currentTime) } 
   let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { disputeOpensFunded gamma};
  assert {forall split. member (DisputeOpen split) gamma.contractStatuses -> isSpent (Normal split.id) gamma };
  (*^ This is unfolded dispute opens funded *)
  assert { forall x . (member x (res.contractStatuses)) -> member x channels \/ member x gamma.contractStatuses}
       
  let lemma gammaInsertContractsAllChannelsFunded (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall channel . member channel channels -> contractStatusFreshForGamma gamma channel}
  requires { forall channel funding . member channel channels -> extractChannelId  channel = Some funding -> not (inputUnspent funding gamma)} 
  ensures  { allChannelsFunded (gammaInsertContracts gamma channels currentTime) } 
  let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { allChannelsFunded gamma};
  assert {  forall channel funding . member channel gamma.contractStatuses -> extractChannelId channel = Some funding -> 
                                     not (inputUnspent funding gamma) };
  (*^ This is unfolded all channels  funded *)
  assert { forall x . (member x (res.contractStatuses)) -> member x channels \/ member x gamma.contractStatuses}
  
  let lemma gammaInsertContractsDisputeOpensUniqueByIdEasy (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall channel split . member channel channels -> channel <> DisputeOpen split } 
  ensures  { disputeOpensUniqueById (gammaInsertContracts gamma channels currentTime)}
  let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { disputeOpensUniqueById gamma};
  assert { forall split1 split2. member (DisputeOpen split1) gamma.contractStatuses -> 
                                 member (DisputeOpen split2) gamma.contractStatuses -> 
                                 split1.id = split2.id -> 
                                 split1 = split2 };
                                 (*^ This is unfolded disputeOpensUniqueById *)
  assert { forall x . (member x (res.contractStatuses)) -> member x channels \/ member x gamma.contractStatuses}
 
  let lemma gammaInsertContractsDisputeOpensUniqueByIdHard (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall split1 split2 . member (DisputeOpen split1) channels ->
                                    member (DisputeOpen split2) channels ->
                                    split1 = split2 } (*I.e there is at most one dispute open in the new channels *)
  requires { forall split1 split2 . member (DisputeOpen split1) channels ->
                                    member (DisputeOpen split2) gamma.allContracts ->
                                    split1.id <> split2.id}                            
  ensures  { disputeOpensUniqueById (gammaInsertContracts gamma channels currentTime)}
  let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { disputeOpensUniqueById gamma};
  assert { forall split1 split2. member (DisputeOpen split1) gamma.allContracts -> 
                                 member (DisputeOpen split2) gamma.allContracts -> 
                                 split1.id = split2.id -> 
                                 split1 = split2 };
                                 (*^ This is unfolded disputeOpensUniqueById *)
  assert { forall x . (member x (res.allContracts)) -> member x channels \/ member x gamma.allContracts}
  
  let lemma gammaInsertContractsNormalCorrectFunding (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall funding . member (Normal funding) channels -> 
                              funding.destination = Channel } 
  ensures  { normalCorrectFunding (gammaInsertContracts gamma channels currentTime)} 
  ()
  
  let lemma gammaInsertContractsGammaNoDuplicates (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall channel. member channel channels -> contractStatusFreshForGamma gamma channel}
  requires { forall channel. num_occ channel channels <= 1 }
  ensures  { gammaNoDuplicates (gammaInsertContracts gamma channels currentTime) }
  ensures  { gammaNoDuplicatesUsed (gammaInsertContracts gamma channels currentTime) }
  let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { forall x . num_occ x res.contractStatuses = num_occ x channels + num_occ x gamma.contractStatuses};
  assert { forall x . num_occ x res.allContracts = num_occ x channels + num_occ x gamma.allContracts};
  assert { forall x . member x channels -> not (member x gamma.allContracts) }; (*unfold contractStatusFreshForGamma in Requires1*)
  assert { forall x . member x channels -> not (member x gamma.contractStatuses) };
  assert { forall x . member x channels -> not (member x gamma.allContracts) }
  
  
  let lemma gammaInsertContractsDisputeOpenCorrectFunding (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires { gammaCoherent gamma } 
  requires { forall split . member (DisputeOpen split) channels -> 
                            split.id.destination = Channel } 
  ensures  { disputeOpenCorrectFunding (gammaInsertContracts gamma channels currentTime)} 
  ()
  
  let lemma gammaInsertCurrentAreUsed (gamma : gammaStateT) (channels : list contractStatusT) (currentTime : timeT) = 
  requires {gammaCoherent gamma}
  ensures  {gammaCurrentAreUsed (gammaInsertContracts gamma channels currentTime)}
  let res = (gammaInsertContracts gamma channels currentTime) in 
  assert { forall x . (member x (res.contractStatuses)) -> member x channels \/ member x gamma.contractStatuses}
  
  
  
  (*Now, we need a class of lemmas that help us show that accounts are fresh for gamma *)
  (*First, we need to show that if an id is fresh for gamma then a normal account with that id is also fresh for gamma*)
  let lemma idFreshSoPublicKeyAccountFresh (gamma : gammaStateT) (amount : amountT) (party : partyT)  (id : idT) = 
  requires { idFreshForGamma gamma id }
  ensures {contractStatusFreshForGamma gamma (PublicKeyAccount amount party id) }
  let publicKeyAccount = PublicKeyAccount amount party id in 
  let _ = mapNotPresent extractAccountId gamma.allContracts publicKeyAccount in
  ()
  
  (*Then we need to show that if a Normal is present on gamma then every matching dispute open is fresh on gamma*)
  let lemma normalUnspentSoDisputeOpenFresh (gamma : gammaStateT) (split : conditionalOutputT) = 
  requires { gammaCoherent gamma }
  requires { member (Normal split.id) gamma.contractStatuses }
  ensures  { contractStatusFreshForGamma gamma (DisputeOpen split) } 
  assert { disputeOpensFunded gamma };
  assert { forall s. member (DisputeOpen s) (contractStatuses gamma) -> isSpent (Normal (s.id)) gamma};
  ()
  
  (*Now, we show that if a PublicKeyAccount is unspent on gamma, then the matching Normal is fresh for gamma*)
  let lemma publicKeyAccountUnspentSoNormalFresh (gamma : gammaStateT) (funding : transferFromPublicKeyAccountT) = 
  requires { gammaCoherent gamma }
  requires { member (expectedContractStatusMoveOwnCoins funding) gamma.contractStatuses }
  ensures  { contractStatusFreshForGamma gamma (Normal funding) }
  assert   { allChannelsFunded gamma };
  ()
    
  (*Finally, we need to show that removing channels does not influence being fresh for gamma *)
  let lemma spendingChannelsPreservesFreshness (gamma : gammaStateT) (toSpend : contractT) (account : contractStatusT) = 
  requires { contractStatusFreshForGamma gamma account } 
  requires { member toSpend gamma.activeContracts } 
  ensures  { contractStatusFreshForGamma (gammaSpendContract gamma toSpend) account } 
  assert   { gammaSpendContract gamma toSpend = {activeContracts = removeOne toSpend gamma.activeContracts; allContracts = gamma.allContracts}}

  let lemma addFreshDoesNotAddDuplicates (gamma : gammaStateT) (msg : msgToGammaT) (id1 id2 : idT) (a1 a2 : amountT) (p1 p2 : partyT) =
  requires {checkFreshness msg gamma}
  requires {member (PublicKeyAccount a1 p1 id1) gamma.allContracts}
  requires {member (PublicKeyAccount a2 p2 id2) msg.evalOut}
  ensures {id1 <> id2}
  match msg with 
    | ClaimAfterTimeout (_, _, id3) 
    | OpenDispute (_, _, id3) 
    | Revoke (_, _, _, id3) -> 
      assert {id2 = id3};
      assert {checkFreshness msg gamma}; 
      assert {not (member id3 gamma.usedIds)}; (*rewrite H in Assert; unfold checkFreshness in Assert*)
      assert {not (member (Some id3) (map extractAccountId gamma.allContracts))};
      assert {not (member (PublicKeyAccount a1 p2 id3) gamma.allContracts)};
      assert {id1 <> id2}
    | MoveOwnCoinsOnChain (_, _, id3, id4) ->
      assert {id2 = id3 \/ id2 = id4};
      assert {checkFreshness msg gamma};
      assert {not (member id3 gamma.usedIds)}; (*rewrite H in Assert; unfold checkFreshness in Assert*)
      assert {member id4 msg.extractIds};
      assert {not (member id4 gamma.usedIds)}; (*unfold checkFreshness in Assert2*)
      assert {not (member (Some id3) (map extractAccountId gamma.allContracts))};
      assert {not (member (Some id4) (map extractAccountId gamma.allContracts))};
      assert {not (member (PublicKeyAccount a1 p2 id3) gamma.allContracts)};
      assert {not (member (PublicKeyAccount a1 p2 id4) gamma.allContracts)};
      assert {id1 <> id2}
  end

  let lemma moveOwnCoinsOnChainFreshSoIdsDifferent (gamma : gammaStateT) (id1 id2 : idT) (args : transferFromPublicKeyAccountT) (sig : signatureT) =
  requires {checkFreshness (MoveOwnCoinsOnChain (args, sig, id1, id2)) gamma}
  ensures {id1 <> id2}
  let msg = MoveOwnCoinsOnChain (args, sig, id1, id2) in 
  assert {extractIds msg = Cons id1 (Cons id2 Nil)};
  if equal id1 id2 then (
    assert {num_occ id1 msg.extractIds = 2};
    absurd (*unfold checkFreshness in Requires*)
  ) else ()


  let function openChannelUniqueId (gamma : gammaStateT) (args args' : transferFromPublicKeyAccountT)  = 
  requires {gammaCoherent gamma}
  requires {args.destination = Channel}
  requires {member args.expectedContractStatusMoveOwnCoins gamma.contractStatuses}
  requires {member (Normal args') gamma.allContracts}
  ensures {args'.fundingId <> args.fundingId}
  if not (compareIDs args.fundingId args'.fundingId) then assert {args'.fundingId <> args.fundingId} else 
  let input  = args.expectedContractStatusMoveOwnCoins in 
  assert {member input gamma.contractStatuses};
  assert {member input gamma.allContracts};
  absurd


  let function gammaProcessMessageFreshWithInvariant (gamma : gammaStateT) (msg : msgToGammaT)
                                                (sigState : signatureFunctionalityT) (time : timeT) =
  requires { gammaCoherent gamma}
  requires {  checkFreshness msg gamma}
  ensures  { result = gammaProcessMsgFresh gamma msg sigState time} 
  ensures  { forall res . result = Some res -> gammaCoherent res}
  let _ans = gammaProcessMsgFreshFull gamma msg sigState time in
  let input = expectedContractStatus msg in
  if isSpent_comp input gamma then None else
  let filtered = filter (fun x -> compareContractStatus x.contractStatus input) gamma.activeContracts in
  match filtered with
    | Nil -> None
    | Cons inputFull _ ->
      assert { inputFull.contractStatus = input };
      match contractProcessMsg inputFull msg sigState time with
      | None -> None
      | Some newChannels ->
        let gammaWithSpentInput = gammaSpendContract gamma inputFull in
        assert {gammaCoherent gammaWithSpentInput};
        let gammaWithNewInputs = gammaInsertContracts gammaWithSpentInput newChannels time in 
        let res = gammaWithNewInputs in 
        assert { gammaProcessMsgFresh gamma msg sigState time = Some res};
        match msg with 
         | ClaimAfterTimeout (_split, _sig, _id) ->
            let _ = gammaInsertContractsDisputeOpensFundedEasy gammaWithSpentInput newChannels time in 
            let _ = gammaInsertContractsGammaNoDuplicates gammaWithSpentInput newChannels time  in 
            let _ = gammaInsertContractsAllChannelsFunded gammaWithSpentInput newChannels time  in 
            let _ = gammaInsertContractsDisputeOpensUniqueByIdEasy gammaWithSpentInput newChannels  time in 
            let _ = gammaInsertContractsNormalCorrectFunding gammaWithSpentInput newChannels time  in     
            assert {normalChannelsUniqueByIdT res};  
            assert {publicKeyAccountsUniqueByIdT res};
            assert {gammaCoherent res}; (*unfold gammaCoherent*)
            Some res
         | OpenDispute (fullSplit, _, newId) ->
            let _ = normalUnspentSoDisputeOpenFresh gamma fullSplit.split.condOutput  in 
            let _ = spendingChannelsPreservesFreshness gamma inputFull (DisputeOpen fullSplit.split.condOutput) in 
            let m1 =  DisputeOpen (fullSplit.split.condOutput) in 
            let m2 = PublicKeyAccount (fullSplit.split.amountUnCond) (other (fullSplit.split.condOutput.partyCond)) newId in 
            assert { newChannels = Cons m1 (Cons m2 Nil) }; 
            assert { forall channel. member channel newChannels -> channel = m1 \/ channel = m2};
            assert { forall channel. member channel newChannels -> contractStatusFreshForGamma gamma channel};
            assert { forall split . member (DisputeOpen split) newChannels -> split = fullSplit.split.condOutput };
            assert { input = (Normal fullSplit.split.condOutput.id) };
            assert { isSpent  (Normal fullSplit.split.condOutput.id) gammaWithSpentInput  };
            assert {forall split . member (DisputeOpen split) newChannels -> isSpent (Normal split.id) gammaWithSpentInput};
            let _ = gammaInsertContractsDisputeOpensFundedHard gammaWithSpentInput newChannels time in 
            let _ = gammaInsertContractsGammaNoDuplicates gammaWithSpentInput newChannels time in 
            let _ = gammaInsertContractsAllChannelsFunded gammaWithSpentInput newChannels time in 
            let _ = gammaInsertContractsDisputeOpensUniqueByIdHard gammaWithSpentInput newChannels time in 
            let _ = gammaInsertContractsNormalCorrectFunding gammaWithSpentInput newChannels time in
            assert {normalChannelsUniqueByIdT res};         
            assert {publicKeyAccountsUniqueByIdT res};
            assert {gammaCoherent res}; (*unfold gammaCoherent*)
            Some res
         | Revoke (_, _, _, _) ->
           let _ = gammaInsertContractsDisputeOpensFundedEasy gammaWithSpentInput newChannels time in 
           let _ = gammaInsertContractsGammaNoDuplicates gammaWithSpentInput newChannels time in 
           let _ = gammaInsertContractsAllChannelsFunded gammaWithSpentInput newChannels time in 
           let _ = gammaInsertContractsDisputeOpensUniqueByIdEasy gammaWithSpentInput newChannels time in 
           let _ = gammaInsertContractsNormalCorrectFunding gammaWithSpentInput newChannels time in 
           assert {normalChannelsUniqueByIdT res};        
           assert {publicKeyAccountsUniqueByIdT res}; 
           assert {gammaCoherent res}; (*unfold gammaCoherent*)
           Some res
         | MoveOwnCoinsOnChain (args, _, id1, id2) ->
           match args.destination with 
             | Void -> 
               let ch =  PublicKeyAccount (args.totalAmount - args.amount) args.sender id1 in                  
               assert { newChannels = Cons ch Nil};
               assert { forall channel . member channel newChannels -> channel = ch } ;
               assert { contractStatusFreshForGamma gammaWithSpentInput ch };
               let _ = gammaInsertContractsDisputeOpensFundedEasy gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsGammaNoDuplicates gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsAllChannelsFunded gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsDisputeOpensUniqueByIdEasy gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsNormalCorrectFunding gammaWithSpentInput newChannels time in  
               assert {normalChannelsUniqueByIdT res};       
               assert {publicKeyAccountsUniqueByIdT res};
               assert {gammaCoherent res}; (*unfold gammaCoherent*)
               Some res
             | OtherParty ->
               let s1 =  PublicKeyAccount args.amount (other args.sender) id2 in 
               let s2 =  PublicKeyAccount (args.totalAmount - args.amount) args.sender id1 in                  
               assert { newChannels = Cons s1 (Cons s2 Nil)};
               assert { forall channel . member channel newChannels -> channel = s1 \/ channel = s2 } ;
               assert { contractStatusFreshForGamma gammaWithSpentInput s1 };
               assert { contractStatusFreshForGamma gammaWithSpentInput s2 };
               let _ = gammaInsertContractsDisputeOpensFundedEasy gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsGammaNoDuplicates gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsAllChannelsFunded gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsDisputeOpensUniqueByIdEasy gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsNormalCorrectFunding gammaWithSpentInput newChannels time in  
               assert {normalChannelsUniqueByIdT res};
               assert {id1 <> id2};
               assert {idFreshForGamma gamma id1};
               assert {idFreshForGamma gamma id2};             
               assert {publicKeyAccountsUniqueByIdT res};
               assert {gammaCoherent res}; (*unfold gammaCoherent*)
               Some res
             | Channel -> 
               let s1 =  Normal args in 
               let s2 =  PublicKeyAccount (args.totalAmount-args.amount) args.sender id1 in                  
               assert { newChannels = Cons s1 (Cons s2 Nil)};
               assert { forall channel . member channel newChannels -> channel = s1 \/ channel = s2 } ;
               assert { contractStatusFreshForGamma gammaWithSpentInput s1 };
               assert { contractStatusFreshForGamma gammaWithSpentInput s2 };
               let _ = gammaInsertContractsDisputeOpensFundedEasy gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsGammaNoDuplicates gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsAllChannelsFunded gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsDisputeOpensUniqueByIdEasy gammaWithSpentInput newChannels time in 
               let _ = gammaInsertContractsNormalCorrectFunding gammaWithSpentInput newChannels time in 
               assert {normalChannelsUniqueByIdT res};        
               assert {publicKeyAccountsUniqueByIdT res};
               assert {gammaCoherent res}; (*unfold gammaCoherent*)
               Some res
           end
        end
      end
  end
 
  let lemma gammaProcessCoherent (gamma : gammaStateT) (msg : msgToGammaT)
                                 (sigState : signatureFunctionalityT) (time : timeT) =
  requires { checkFreshness msg gamma}
  requires { gammaCoherent gamma}
  ensures  { gammaCoherent  (gammaProcessMsgFreshFull gamma msg sigState time) }
  let res = gammaProcessMsgFreshFull gamma msg sigState time in 
  match gammaProcessMessageFreshWithInvariant gamma msg sigState time with 
    | None -> assert {res = gamma}; assert {gammaCoherent res}
    | Some x -> assert {x = res}; assert {gammaCoherent res}
  end
  
  let lemma msgFreshSoEvalOutFresh (msg : msgToGammaT) (g : gammaStateT) = 
  requires {gammaCoherent g}
  requires {checkFreshness msg g} 
  requires { not (isSpent (expectedContractStatus msg) g)}
  ensures  {forall x . member x (evalOut msg) -> contractStatusFreshForGamma g x }
  match msg with 
    | ClaimAfterTimeout (_, _, _) ->
       assert  {forall x . member x (evalOut msg) -> contractStatusFreshForGamma g x }
    | OpenDispute (_ , _ , _) -> 
       assert  {forall x . member x (evalOut msg) -> contractStatusFreshForGamma g x }
    | Revoke (_, _ , _, _) -> 
      assert  {forall x . member x (evalOut msg) -> contractStatusFreshForGamma g x }
    | MoveOwnCoinsOnChain (_, _, _, _) -> 
       assert  {forall x . member x (evalOut msg) -> contractStatusFreshForGamma g x }
  end

  let lemma addMoneyFromVoidPreservesCoherent (gamma : gammaStateT) (id : idT) (amount : amountT) (party : partyT) (time : timeT) =
  requires {gammaCoherent gamma}
  requires {amount >= 0}
  ensures  {gammaCoherent (addMoneyFromVoid gamma id amount party time)}
  let st = gammaCoherent (addMoneyFromVoid gamma id amount party time) in
  if not (idFreshForGamma gamma id) then assert {st} else
  let newChannel = PublicKeyAccount amount party id in
  let newChannelFull = {contractStatus = newChannel; lastContractTransitionTime = time} in
  let newGamma = {activeContracts = Cons newChannelFull gamma.activeContracts; allContracts = Cons newChannel gamma.allContracts} in
  assert {newGamma = addMoneyFromVoid gamma id amount party time};
  assert {newChannel.extractAccountId = Some id};
  assert {not (member newChannel gamma.allContracts)};
  assert {not (member newChannel gamma.contractStatuses)};
  assert {forall x. isSpent x gamma = isSpent x newGamma};
  assert {gammaNoDuplicatesUsed newGamma};
  assert {newChannel.extractChannelId = None};
  assert {allChannelsFunded gamma};
  assert {forall ch. ch.extractChannelId <> None -> member ch newGamma.allContracts -> member ch gamma.allContracts};
  assert {allChannelsFunded newGamma}; (*unfold allChannelsFunded*)
  assert {disputeOpensFunded newGamma};
  assert {forall x. member x newGamma.contractStatuses <-> member x gamma.contractStatuses \/ x = newChannel};
  assert {publicKeyAccountsUniqueByIdT gamma};
  assert {forall x y z. (PublicKeyAccount x y z).extractAccountId = Some z};
  assert {forall x y z. member (PublicKeyAccount x y z) gamma.contractStatuses -> member z gamma.usedIds};
  assert {forall z. member z gamma.usedIds -> z <> id};
  assert {forall x y z. member (PublicKeyAccount x y z) gamma.contractStatuses -> z <> id};
  assert {publicKeyAccountsUniqueByIdT newGamma};
  assert {gammaCurrentAreUsed newGamma}; (*unfold gammaCurrentAreUsed*)
  assert {gammaCoherent newGamma} (*unfold gammaCoherent*)

end (*GammaInvariantProofs*)


module EvaluatorPreservationProofs : EvaluatorPreservationLemmas
  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  use basicTypes.Compare
  use list.Append
  
  use list.Nth
  
  use signaturesFunctionality.SignaturesFunctionality
  (*use partyInterface.PartyInterface*)
  use export Gamma
  use export Evaluator
  use Evaluator
  use GammaInvariant
  use GammaInvariantLemmas
  use GammaBasicLemmas
  use EvaluatorBasicLemmas
  
  
  (*The goal of this module is to prove that partyExpectations does not decrease when gamma makes a move,
    i.e gammaProcessMsgPreservesEvaluator (see the end of this section)*)
    
    
  (*We start with a few easy lemmas *)
   let lemma worstCaseChannelResolutionMsgsPermutationsInvariant (sigs : signatureFunctionalityT)  (channel : contractT) 
                                                                 (p : partySplitsAndRevocationsRecordStrictT)
                                                                 (lastWoken : timeT) (msgs msgs2 : list (msgToGammaT, timeT)) =                             
   requires { forall x . num_occ x msgs = num_occ x msgs2 }
   ensures  { worstCaseChannelResolution sigs channel p lastWoken msgs = worstCaseChannelResolution sigs channel p lastWoken msgs2}
   let st = worstCaseChannelResolution sigs channel p lastWoken msgs = worstCaseChannelResolution sigs channel p lastWoken msgs2 in 
   match channel.contractStatus with 
     | Normal _ -> assert {st};
     | PublicKeyAccount _ _ _  -> assert {st};
     | DisputeOpen _ -> assert {st};  (*finisher*)
   end                                                     
    
  
  let function amountReviewedWhenOpened (p : partyT) (s : splitT) : amountT = 
    if compareParties s.condOutput.partyCond p then 0 else s.amountUnCond  
  
  
  let function worstCaseChannelsResolution (sigs : signatureFunctionalityT) (channels : list contractT) (p : partySplitsAndRevocationsRecordStrictT) 
                                           (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  sum (map (fun x -> worstCaseChannelResolution sigs x p lastWoken msgs) channels)
  
  let function worstCaseChannelsResolutionGeneral (sigs : signatureFunctionalityT) (channels : list contractT)
                                                  (p : partySplitsAndRevocationsRecordGeneralT) 
                                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  sum (map (fun x -> worstCaseChannelResolutionFull sigs x p lastWoken msgs) channels)
  
  let lemma worstCaseChannelsResolutionWorstCaseChannelsResolutionGeneral (sigs : signatureFunctionalityT) 
                                                                        (channels : list contractT)
                                                                        (p : partySplitsAndRevocationsRecordGeneralT)
                                                                        (p' : partySplitsAndRevocationsRecordStrictT)
                                                                        (lastWoken : timeT) 
                                                                        (msgs : list (msgToGammaT, timeT)) =
  requires { makeStrict p = Some p' }
  ensures  { worstCaseChannelsResolution sigs channels p' lastWoken msgs =
             worstCaseChannelsResolutionGeneral sigs channels p lastWoken msgs }
  ()

  
  
  let function worstCaseChannelsStatusResolution (sigs : signatureFunctionalityT) (channels : list contractStatusT) (p : partySplitsAndRevocationsRecordStrictT)
                                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  let newChannelsFull = map (fun x -> {contractStatus = x; lastContractTransitionTime = currentTime}) channels in 
  worstCaseChannelsResolution sigs newChannelsFull p lastWoken msgs
  
  
  let function worstCaseChannelsStatusResolutionGeneral (sigs : signatureFunctionalityT) (channels : list contractStatusT)
                                                 (p : partySplitsAndRevocationsRecordGeneralT)
                                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  let newChannelsFull = map (fun x -> {contractStatus = x; lastContractTransitionTime = currentTime}) channels in 
  worstCaseChannelsResolutionGeneral sigs newChannelsFull p lastWoken msgs
  
  let lemma worstCaseChannelsStatusResolutionWorstCaseChannelsStatusResolutionGeneral
              (sigs : signatureFunctionalityT) 
              (channels : list contractStatusT)
              (p : partySplitsAndRevocationsRecordGeneralT)
              (p' : partySplitsAndRevocationsRecordStrictT)
              (lastWoken : timeT) 
              (msgs : list (msgToGammaT, timeT)) 
              (currentTime : timeT) =
  requires { makeStrict p = Some p' }
  ensures  { worstCaseChannelsStatusResolution sigs channels p' lastWoken msgs currentTime =
             worstCaseChannelsStatusResolutionGeneral sigs channels p lastWoken msgs currentTime }
  ()

  
  let function msgNetLoss (msg : msgToGammaT) 
                          (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =                    
  match msg with 
    | MoveOwnCoinsOnChain (args, _, _, _) ->
        transactionNetLoss args sigs p lastWoken msgs
    | _ -> 0
  end 
  
  let function msgNetLossGeneral (msg : msgToGammaT) 
                                 (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =                    
  match msg with 
    | MoveOwnCoinsOnChain (args, _, _, _) ->
        transactionNetLossFull args sigs p lastWoken msgs
    | _ -> 0
  end 
  
  let lemma msgNetLossMsgNetLossGeneral (msg : msgToGammaT) 
                                        (sigs : signatureFunctionalityT)
                                        (p : partySplitsAndRevocationsRecordGeneralT) 
                                        (p': partySplitsAndRevocationsRecordStrictT)
                                        (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires { makeStrict p = Some  p'}
  ensures  { msgNetLoss msg sigs p' lastWoken msgs = msgNetLossGeneral msg sigs p lastWoken msgs}
  ()
  
  
  let function msgDelta (inputChannelFull : contractT) (msg : msgToGammaT) (sigs : signatureFunctionalityT) 
                        (p : partySplitsAndRevocationsRecordStrictT) 
                        (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                        (currentTime : timeT) (msgDeadline : timeT) = 
  let before = worstCaseChannelResolution sigs inputChannelFull p lastWoken (Cons (msg, msgDeadline) msgs) in 
  let newStatuses = evalOut msg in 
  let after = worstCaseChannelsStatusResolution sigs newStatuses p lastWoken msgs currentTime in 
  let msgNetLoss = msgNetLoss msg sigs p lastWoken (Cons (msg, msgDeadline) msgs) in  
  after - before + msgNetLoss
  
  
  let function msgDeltaGeneral (inputChannelFull : contractT) (msg : msgToGammaT) (sigs : signatureFunctionalityT) 
                               (p : partySplitsAndRevocationsRecordGeneralT) 
                               (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                               (currentTime : timeT) (msgDeadline : timeT) = 
  let before = worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken (Cons (msg, msgDeadline) msgs) in 
  let newStatuses = evalOut msg in 
  let after = worstCaseChannelsStatusResolutionGeneral sigs newStatuses p lastWoken msgs currentTime in 
  let msgNetLoss = msgNetLossGeneral msg sigs p lastWoken (Cons (msg, msgDeadline) msgs) in  
  after - before + msgNetLoss
  
  let lemma msgDeltaMsgDeltaGeneral (inputChannelFull : contractT) (msg : msgToGammaT) (sigs : signatureFunctionalityT) 
                                    (p : partySplitsAndRevocationsRecordGeneralT) 
                                    (p' : partySplitsAndRevocationsRecordStrictT) 
                                    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                    (currentTime : timeT) (msgDeadline : timeT) = 
  requires { makeStrict p = Some p'}
  ensures { msgDeltaGeneral inputChannelFull msg sigs p  lastWoken msgs currentTime msgDeadline = 
            msgDelta        inputChannelFull msg sigs p' lastWoken msgs currentTime msgDeadline}
  ()
  
  

      
  let lemma worstCaseChannelResolutionGPositive (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordGeneralT)
                                                (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) =
  requires {goodStatus channelFull.contractStatus}
  ensures { worstCaseChannelResolutionFull sigs channelFull p lastWoken msgs  >= 0 }
  match makeStrict p with 
    | None -> assert { worstCaseChannelResolutionFull sigs channelFull p lastWoken msgs  >= 0 }
    | Some _ -> assert { worstCaseChannelResolutionFull sigs channelFull p lastWoken msgs  >= 0 }
  end
  
  
  let lemma deltaPositiveWhenOpenDispute (inputChannelFull : contractT) 
                                         (hsSplit : halfSignedSplitT) (sig : signatureT) (accId : idT) 
                                         (sigs : signatureFunctionalityT)
                                         (p : partySplitsAndRevocationsRecordStrictT) 
                                         (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                         (currentTime : timeT) (msgDeadline : timeT) = 
  requires {inputChannelFull.contractStatus = expectedContractStatus (OpenDispute (hsSplit, sig, accId))}
  requires {verify (other hsSplit.split.condOutput.partyCond) (SignableSplit hsSplit.split) hsSplit.sigUnCond sigs }
  requires {verify (hsSplit.split.condOutput.partyCond) (SignableSplit hsSplit.split) sig sigs }     
  requires {goodSplit hsSplit.split}   
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}            
  ensures {msgDelta inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  let st = msgDelta inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0 in 
  let msg = (OpenDispute (hsSplit, sig, accId)) in 
  let msgsBefore = (Cons (msg, msgDeadline) msgs) in 
  let afterChannel = DisputeOpen hsSplit.split.condOutput in 
  let afterAccount = PublicKeyAccount hsSplit.split.amountUnCond (other hsSplit.split.condOutput.partyCond) accId in 
  let beforeVal = worstCaseChannelResolution sigs inputChannelFull p lastWoken msgsBefore in 
  let afterChannelVal =  worstCaseChannelResolution sigs {contractStatus = afterChannel; lastContractTransitionTime = currentTime} p lastWoken msgs in 
  let afterAccountVal =  worstCaseChannelResolution sigs {contractStatus = afterAccount; lastContractTransitionTime = currentTime} p lastWoken msgs in 
  assert {  msgDelta inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline =   
            afterChannelVal + afterAccountVal - beforeVal };
  (*^ unfold msgDelta; unfold evalOut; unfold worstCaseChannelsStatusResolution; unfold worstCaseChannelsResolution*)
  assert {inputChannelFull.contractStatus = Normal hsSplit.split.condOutput.id};
  let splitsSigned = extractSignedSplits (getSignedBy sigs (p.recordOwner)) in 
  let revsSigned = extractRevokedSplits (getSignedBy sigs (p.recordOwner)) in 
  let revsReceived = extractRevocationsReceived (p.recordOwner) sigs (p.receivedRevocations) in 
  if not compareParties p.bestSplitReceived.split.condOutput.partyCond p.recordOwner then assert {st} else (
  if not (verify (other p.bestSplitReceived.split.condOutput.partyCond) (SignableSplit p.bestSplitReceived.split) p.bestSplitReceived.sigUnCond sigs) then assert {st} else (
  if not (checkApplicableSplitToNormal hsSplit.split.condOutput.id p.bestSplitReceived.split) then assert {st} else (
  assert { p.recordOwner = hsSplit.split.condOutput.partyCond \/ p.recordOwner = other hsSplit.split.condOutput.partyCond};
  assert { exists sig. verify p.recordOwner (SignableSplit hsSplit.split) sig sigs};
  assert { member (SignableSplit hsSplit.split) (getSignedBy sigs p.recordOwner) };
  assert { member hsSplit.split splitsSigned };
  assert { isSome (expectedSplitResolutionOption p.recordOwner hsSplit.split.condOutput.id revsSigned revsReceived  hsSplit.split) };
  assert { expectedSplitResolutionOption p.recordOwner hsSplit.split.condOutput.id revsSigned revsReceived  hsSplit.split = 
           Some (expectedSplitResolutionTotal p.recordOwner revsSigned revsReceived hsSplit.split)}; 
  let signedSplitsExpectedResolutions = catMaybes (map (expectedSplitResolutionOption p.recordOwner  hsSplit.split.condOutput.id  revsSigned revsReceived) splitsSigned) in
  (*minListAux hsResult signedSplitsExpectedResolutions*)
  assert { member (expectedSplitResolutionTotal p.recordOwner revsSigned revsReceived hsSplit.split) signedSplitsExpectedResolutions};
  assert { beforeVal <= (expectedSplitResolutionTotal p.recordOwner revsSigned revsReceived hsSplit.split) };
  assert { afterAccountVal = unCondPayment p.recordOwner hsSplit.split};
  assert {goodConditionalOutput (hsSplit.split.condOutput)};
  assert { afterChannelVal = expectedSplitResolutionWhenDispute p.recordOwner revsSigned revsReceived hsSplit.split.condOutput}
  (*^ unfold afterChannelVal; unfold worstCaseChannelResolution*)
  ))) 
  
  let lemma deltaPositiveWhenOpenDisputeG (inputChannelFull : contractT) 
                                          (hsSplit : halfSignedSplitT) (sig : signatureT) (accId : idT) 
                                          (sigs : signatureFunctionalityT)
                                          (p : partySplitsAndRevocationsRecordGeneralT) 
                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                          (currentTime : timeT) (msgDeadline : timeT) = 
  requires {inputChannelFull.contractStatus = expectedContractStatus (OpenDispute (hsSplit, sig, accId))}
  requires {verify (other hsSplit.split.condOutput.partyCond) (SignableSplit hsSplit.split) hsSplit.sigUnCond sigs }
  requires {verify (hsSplit.split.condOutput.partyCond) (SignableSplit hsSplit.split) sig sigs }     
  requires {goodSplit hsSplit.split}   
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}            
  ensures  { msgDeltaGeneral inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  match makeStrict p with 
    | Some p' -> let _ = deltaPositiveWhenOpenDispute inputChannelFull hsSplit sig accId sigs p' lastWoken msgs currentTime msgDeadline in 
                 assert { msgDeltaGeneral inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
    | None ->
      let _accountOut = { contractStatus = (PublicKeyAccount hsSplit.split.amountUnCond (other hsSplit.split.condOutput.partyCond) accId);
                         lastContractTransitionTime = currentTime } in 
      assert { msgDeltaGeneral inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline =
               worstCaseChannelResolutionFull sigs (contractT'mk (DisputeOpen (hsSplit.split.condOutput)) currentTime) p lastWoken msgs
             + worstCaseChannelResolutionFull sigs (contractT'mk (PublicKeyAccount (hsSplit.split.amountUnCond) (other (hsSplit.split.condOutput.partyCond)) accId) currentTime) p lastWoken msgs
             - worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken (Cons (OpenDispute (hsSplit, sig, accId), msgDeadline) msgs)
      }; (*unfold msgDeltaGeneral; unfold worstCaseChannelsStatusResolutionGeneral; unfold worstCaseChannelsResolutionGeneral; unfold evalOut*)
      assert { msgDeltaGeneral inputChannelFull (OpenDispute (hsSplit, sig, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
      (*^ unfold msgDeltaGeneral; unfold worstCaseChannelsStatusResolutionGeneral; unfold worstCaseChannelsResolutionGeneral; unfold evalOut; unfold worstCaseChannelResolutionFull*)
  end
  
  
  let lemma deltaPositiveWhenRevoke (inputChannelFull : contractT)
                                    (split : conditionalOutputT) (sigRevocation : signatureT) (sigSpender : signatureT) (accId : idT)
                                    (p : partySplitsAndRevocationsRecordStrictT) 
                                    (sigs : signatureFunctionalityT)
                                    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                    (currentTime : timeT) (msgDeadline : timeT) =
  requires { inputChannelFull.contractStatus = expectedContractStatus (Revoke (split, sigRevocation, sigSpender, accId)) }
  requires { verify split.partyCond (SignableRevoke split) sigRevocation sigs }
  requires { goodConditionalOutput split }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}            
  ensures  { msgDelta inputChannelFull (Revoke (split, sigRevocation, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  let st = msgDelta inputChannelFull (Revoke (split, sigRevocation, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0 in 
  let msg = Revoke (split, sigRevocation, sigSpender, accId) in 
  let msgsBefore = (Cons (msg, msgDeadline) msgs) in 
  let beforeStatus = DisputeOpen split in 
  let afterStatus = PublicKeyAccount split.amountCond (other split.partyCond) accId in 
  let afterFull = {contractStatus = afterStatus; lastContractTransitionTime = currentTime} in 
  let beforeVal = worstCaseChannelResolution sigs inputChannelFull p lastWoken msgsBefore in 
  let afterVal  = worstCaseChannelResolution sigs afterFull        p lastWoken msgs       in
  assert {inputChannelFull.contractStatus = beforeStatus};
  assert { msgDelta inputChannelFull msg sigs p lastWoken msgs currentTime msgDeadline =  afterVal - beforeVal};
  (*^unfold msgDelta; unfold msg; unfold worstCaseChannelsStatusResolution; unfold worstCaseChannelsResolution; unfold evalOut*); 
  if compareParties p.recordOwner (other split.partyCond) then assert {st}
  else assert {st} (*unfold beforeVal in Assert; unfold afterVal in Assert; unfold worstCaseChannelResolution in Assert; unfold expectedSplitResolutionWhenDispute_comp in Assert*)
  
  let lemma deltaPositiveWhenRevokeG (inputChannelFull : contractT)
                                    (split : conditionalOutputT) (sigRevocation : signatureT) (sigSpender : signatureT) (accId : idT)
                                    (p : partySplitsAndRevocationsRecordGeneralT) 
                                    (sigs : signatureFunctionalityT)
                                    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                    (currentTime : timeT) (msgDeadline : timeT) =
  requires { inputChannelFull.contractStatus = expectedContractStatus (Revoke (split, sigRevocation, sigSpender, accId)) }
  requires { verify split.partyCond (SignableRevoke split) sigRevocation sigs }
  requires { goodConditionalOutput split }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}            
  ensures  { msgDeltaGeneral inputChannelFull (Revoke (split, sigRevocation, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  match makeStrict p with 
    | Some p' -> let _ = deltaPositiveWhenRevoke inputChannelFull split sigRevocation sigSpender accId p' sigs lastWoken msgs currentTime msgDeadline in 
                 assert { msgDeltaGeneral inputChannelFull (Revoke (split, sigRevocation, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
    | None -> assert {
              msgDeltaGeneral inputChannelFull (Revoke (split, sigRevocation, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline = 
                worstCaseChannelResolutionFull sigs
                  (contractT'mk
                   (PublicKeyAccount (split.amountCond) (other (split.partyCond)) accId)
                   currentTime)
                  p lastWoken msgs
                - worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken
                  (Cons (Revoke (split, sigRevocation, sigSpender, accId), msgDeadline) msgs)
                + msgNetLossGeneral (Revoke (split, sigRevocation, sigSpender, accId))
                  sigs p lastWoken
                  (Cons (Revoke (split, sigRevocation, sigSpender, accId), msgDeadline) msgs)
            }; (*unfold msgDeltaGeneral*)
            assert { msgDeltaGeneral inputChannelFull (Revoke (split, sigRevocation, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
      
  end
  
  let lemma deltaPositiveWhenClaimAfterTimeout (inputChannelFull : contractT)
                                               (split : conditionalOutputT) (sigSpender : signatureT) (accId : idT)
                                               (p : partySplitsAndRevocationsRecordStrictT) 
                                               (sigs : signatureFunctionalityT)
                                               (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                               (currentTime : timeT) (msgDeadline : timeT) =
  requires { inputChannelFull.contractStatus = expectedContractStatus (ClaimAfterTimeout (split, sigSpender, accId)) }
  requires { goodConditionalOutput split }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}  
  requires { currentTime >= inputChannelFull.lastContractTransitionTime + channelTimelock } 
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime} 
  ensures  { msgDelta inputChannelFull (ClaimAfterTimeout (split, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  let st = msgDelta inputChannelFull (ClaimAfterTimeout (split, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0 in 
  let msg = ClaimAfterTimeout (split, sigSpender, accId) in 
  let lastTxTime = inputChannelFull.lastContractTransitionTime in 
  let msgsBefore = (Cons (msg, msgDeadline) msgs) in 
  let beforeStatus = DisputeOpen split in 
  let afterStatus = PublicKeyAccount split.amountCond split.partyCond accId in 
  let afterFull = {contractStatus = afterStatus; lastContractTransitionTime = currentTime} in 
  let beforeVal = worstCaseChannelResolution sigs inputChannelFull p lastWoken msgsBefore in 
  let afterVal  = worstCaseChannelResolution sigs afterFull        p lastWoken msgs       in
  assert {inputChannelFull.contractStatus = beforeStatus};
  assert { msgDelta inputChannelFull msg sigs p lastWoken msgs currentTime msgDeadline =  afterVal - beforeVal};          
  (*^unfold msgDelta; unfold msg; unfold worstCaseChannelsStatusResolution; unfold evalOut*)
  if compareParties p.recordOwner split.partyCond then assert {st} else
  (
   assert { afterVal = 0};
   assert { lastWoken + deltaNet + deltaWake >= lastTxTime + channelTimelock };
   assert {forall m t. member (m, t) msgs -> t >= lastTxTime + channelTimelock - deltaNet};
   assert {forall m t. member (m, t) msgs ->
                       not (correctAndEarlyEnoughRevokeMsg sigs split (lastTxTime + channelTimelock - deltaNet)) (m, t)};
   assert { beforeVal = 0};
   (*^unfold beforeVal; unfold worstCaseChannelResolution; rewrite Assert5*)
   assert {st}
  )
  
  let lemma deltaPositiveWhenClaimAfterTimeoutG (inputChannelFull : contractT)
                                               (split : conditionalOutputT) (sigSpender : signatureT) (accId : idT)
                                               (p : partySplitsAndRevocationsRecordGeneralT) 
                                               (sigs : signatureFunctionalityT)
                                               (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                               (currentTime : timeT) (msgDeadline : timeT) =
  requires { inputChannelFull.contractStatus = expectedContractStatus (ClaimAfterTimeout (split, sigSpender, accId)) }
  requires { goodConditionalOutput split }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}  
  requires { currentTime >= inputChannelFull.lastContractTransitionTime + channelTimelock } 
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime} 
  ensures  { msgDeltaGeneral inputChannelFull (ClaimAfterTimeout (split, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  match makeStrict p with 
    | Some p' -> let _ = deltaPositiveWhenClaimAfterTimeout inputChannelFull split sigSpender accId p' sigs lastWoken msgs currentTime msgDeadline in 
                 assert  { msgDeltaGeneral inputChannelFull (ClaimAfterTimeout (split, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
    | None -> assert  { msgDeltaGeneral inputChannelFull (ClaimAfterTimeout (split, sigSpender, accId)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
              (*^ unfold msgDeltaGeneral; unfold worstCaseChannelsStatusResolutionGeneral; unfold evalOut*)
  end
  
  let lemma deltaPositiveWhenMoveOwnCoinsOtherPartyG
    (inputChannelFull : contractT)
    (args : transferFromPublicKeyAccountT) (sigSpender : signatureT) (id1 : idT) (id2 : idT)
    (p : partySplitsAndRevocationsRecordGeneralT) 
    (sigs : signatureFunctionalityT)
    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
    (currentTime : timeT) (msgDeadline : timeT) =                                  
  requires { inputChannelFull.contractStatus = expectedContractStatus (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) }
  requires { verify args.sender  (SignableTX args) sigSpender sigs }
  requires { transferFromPublicKeyAccountCorrect args }
  requires { args.destination = OtherParty}
  ensures  { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  assert {  msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline = 
  (((worstCaseChannelResolutionFull sigs
     (contractT'mk
      (PublicKeyAccount (args.amount) (other (args.sender)) id2) currentTime)
     p lastWoken msgs
     + worstCaseChannelResolutionFull sigs
       (contractT'mk
        (PublicKeyAccount (args.totalAmount - args.amount) (args.sender) id1)
        currentTime)
       p lastWoken msgs)
    - worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken
      (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs))
   + msgNetLossGeneral (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p
     lastWoken
     (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs))};
  (* unfold msgDeltaGeneral; unfold worstCaseChannelsStatusResolutionGeneral; unfold worstCaseChannelsResolutionGeneral*)
  match makeStrict p with 
    | Some _ ->
      match (args.sender, p.recordOwnerG) with 
      | (A, A)
      | (B, B)  -> 
      if compareParties args.sender p.recordOwnerG then 
      assert {worstCaseChannelResolutionFull sigs (contractT'mk (PublicKeyAccount (args.amount) (other (args.sender)) id2) currentTime)  p lastWoken msgs= 0};
      assert {worstCaseChannelResolutionFull sigs (contractT'mk (PublicKeyAccount (args.totalAmount - args.amount) (args.sender) id1) currentTime) p lastWoken msgs =
              args.totalAmount - args.amount };
      assert {worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs) =
              args.totalAmount};
      assert {msgNetLossGeneral (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs) = args.amount};
      (*unfold msgNetLossGeneral; unfold transactionNetLossFull*)
      assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
      | (A, B) 
      | (B, A) -> 
      assert {worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs) =
             0};
      assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
      (*rewrite Assert1; unfold worstCaseChannelResolutionFull; unfold msgNetLossGeneral*)
      end
    | None ->
      assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0} 
  end
  
  
  let lemma deltaPositiveWhenMoveOwnCoinsChannelG (inputChannelFull : contractT)
                                                (args : transferFromPublicKeyAccountT) (sigSpender : signatureT) (id1 : idT) (id2 : idT)
                                                (p : partySplitsAndRevocationsRecordGeneralT) 
                                                (sigs : signatureFunctionalityT)
                                                (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                                (currentTime : timeT) (msgDeadline : timeT) =                                  
  requires { inputChannelFull.contractStatus = expectedContractStatus (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) }
  requires { verify args.sender  (SignableTX args) sigSpender sigs }
  requires { transferFromPublicKeyAccountCorrect args }
  requires { args.destination = Channel}
  ensures  { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline = 
  (((worstCaseChannelResolutionFull sigs
     (contractT'mk (Normal args) currentTime) p lastWoken msgs
     + worstCaseChannelResolutionFull sigs
       (contractT'mk
        (PublicKeyAccount (args.totalAmount - args.amount) (args.sender) id1)
        currentTime)
       p lastWoken msgs)
    - worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken
      (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs))
   + msgNetLossGeneral (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p
     lastWoken
     (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs))};
  (* unfold msgDeltaGeneral; unfold worstCaseChannelsStatusResolutionGeneral; unfold worstCaseChannelsResolutionGeneral*)
  match makeStrict p with 
    | Some _ ->
      match (args.sender, p.recordOwnerG) with 
      | (A, A)
      | (B, B)  -> 
        assert { worstCaseChannelResolutionFull sigs (contractT'mk (PublicKeyAccount (args.totalAmount - args.amount) (args.sender) id1) currentTime) p lastWoken msgs= args.totalAmount - args.amount};
        assert { worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs) = args.totalAmount};
        assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
        (*unfold msgDeltaGeneral; unfold msgNetLossGeneral; unfold evalOut; finisher*)
      | (B, A) 
      | (A, B) -> 
        assert { worstCaseChannelResolutionFull sigs (contractT'mk (PublicKeyAccount (args.totalAmount - args.amount) (args.sender) id1) currentTime) p lastWoken msgs= 0};
        assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0} (*finisher*)
      end 
    | None ->  assert  { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  end
  
  let lemma deltaPositiveWhenMoveOwnCoinsVoidG (inputChannelFull : contractT)
                                              (args : transferFromPublicKeyAccountT) (sigSpender : signatureT) (id1 : idT) (id2 : idT)
                                              (p : partySplitsAndRevocationsRecordGeneralT) 
                                              (sigs : signatureFunctionalityT)
                                              (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                              (currentTime : timeT) (msgDeadline : timeT) =
  requires { inputChannelFull.contractStatus = expectedContractStatus (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) }
  requires { verify args.sender  (SignableTX args) sigSpender sigs }
  requires { transferFromPublicKeyAccountCorrect args }
  requires { args.destination = Void}
  ensures  { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0}
  assert { msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline = 
  (( worstCaseChannelResolutionFull sigs
       (contractT'mk
        (PublicKeyAccount (args.totalAmount - args.amount) (args.sender) id1)
        currentTime)
       p lastWoken msgs)
    - worstCaseChannelResolutionFull sigs inputChannelFull p lastWoken
      (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs))
   + msgNetLossGeneral (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p
     lastWoken
     (Cons (MoveOwnCoinsOnChain (args, sigSpender, id1, id2), msgDeadline) msgs)};
  (*^ unfold msgDeltaGeneral; unfold worstCaseChannelsStatusResolutionGeneral; unfold worstCaseChannelsResolutionGeneral*)
  assert {msgDeltaGeneral inputChannelFull (MoveOwnCoinsOnChain (args, sigSpender, id1, id2)) sigs p lastWoken msgs currentTime msgDeadline >= 0} (*finisher *)
  

  let lemma deltaPositiveG (inputChannelFull : contractT)
                         (msg : msgToGammaT)
                         (p : partySplitsAndRevocationsRecordGeneralT) 
                         (sigs : signatureFunctionalityT)
                         (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                         (currentTime : timeT) (msgDeadline : timeT) =
  requires { goodStatus inputChannelFull.contractStatus }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake}  
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime}
  requires { msgApplicable inputChannelFull.contractStatus msg } 
  requires { verificationCheck msg sigs }
  requires { timeCheck msg inputChannelFull.lastContractTransitionTime currentTime }
  requires { goodMsg msg} 
  requires { goodStatus inputChannelFull.contractStatus}
  ensures  { msgDeltaGeneral inputChannelFull msg sigs p lastWoken msgs currentTime msgDeadline >= 0 }
  let st = msgDeltaGeneral inputChannelFull msg sigs p lastWoken msgs currentTime msgDeadline >= 0 in 
  match msg with
    | ClaimAfterTimeout (split, sigSpender, accId) -> 
      assert {goodStatus ( expectedContractStatus (ClaimAfterTimeout (split, sigSpender, accId)))};
      let _ = deltaPositiveWhenClaimAfterTimeoutG inputChannelFull split sigSpender accId p sigs lastWoken msgs currentTime msgDeadline in 
      assert {st}
    | Revoke (split, sigRevocation, sigSpender, accId) ->
      assert {goodStatus ( expectedContractStatus (Revoke (split, sigRevocation, sigSpender, accId)))};
      let _ = deltaPositiveWhenRevokeG inputChannelFull split sigRevocation sigSpender accId p sigs lastWoken msgs currentTime msgDeadline in 
      assert {st};
    | OpenDispute (hsSplit, sig, accId) ->
      let _ = deltaPositiveWhenOpenDisputeG inputChannelFull hsSplit sig accId sigs p lastWoken msgs currentTime msgDeadline in 
      assert {st};
    | MoveOwnCoinsOnChain (args, sig, id1, id2) ->
      assert {goodMsg (MoveOwnCoinsOnChain (args, sig, id1, id2)) };
      match args.destination with 
        | Channel -> 
          let _ = deltaPositiveWhenMoveOwnCoinsChannelG inputChannelFull args sig id1 id2 p sigs lastWoken msgs currentTime msgDeadline in 
          assert {st};
        | OtherParty -> 
          let _ = deltaPositiveWhenMoveOwnCoinsOtherPartyG inputChannelFull args sig id1 id2 p sigs lastWoken msgs currentTime msgDeadline in
          assert {st};
        | Void -> assert {st};
      end
  end

  
  
  let predicate applicableRevokeMsgForStatus (s : contractStatusT)  (sigs : signatureFunctionalityT) (msg : msgToGammaT) = 
  match s with 
    | DisputeOpen msplit -> applicableRevokeMsg sigs msplit msg
    | _ -> false
  end
  
  let lemma differentInputSoNotCorrectRevokeForStatus (s : contractStatusT) (sigs : signatureFunctionalityT) (msg : msgToGammaT) = 
  requires { s <> expectedContractStatus msg }
  ensures { not (applicableRevokeMsgForStatus s sigs msg)} 
  match s with 
    | DisputeOpen msplit ->
      match msg with 
        | Revoke (split, _, _, _) ->
               assert {msplit <> split};
               assert {not (applicableRevokeMsgForStatus s sigs msg)};
        | _ -> assert {not (applicableRevokeMsgForStatus s sigs msg)};
      end
    | _ -> assert {not (applicableRevokeMsgForStatus s sigs msg)}
  end
  
  let lemma worstCaseChannelResolutionSkipNonCorrectG
    (sigs : signatureFunctionalityT) (channelFull : contractT) (p : partySplitsAndRevocationsRecordGeneralT)
    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (msg : msgToGammaT) (msgDeadline : timeT) =
  requires { not (applicableRevokeMsgForStatus channelFull.contractStatus sigs msg) }
  ensures { worstCaseChannelResolutionFull sigs channelFull p lastWoken msgs = 
            worstCaseChannelResolutionFull sigs channelFull p lastWoken (Cons (msg, msgDeadline) msgs) }
  let st = worstCaseChannelResolutionFull sigs channelFull p lastWoken msgs = 
           worstCaseChannelResolutionFull sigs channelFull p lastWoken (Cons (msg, msgDeadline) msgs) in 
  match channelFull.contractStatus with 
    | DisputeOpen _ -> assert {st}; 
    | Normal _ -> assert {st};
    | PublicKeyAccount _ _ _ -> assert {st};
  end
  
  let lemma partyExpectationsSkipNonCorrectG (g : gammaStateT) (sigs : signatureFunctionalityT) 
                                           (p : partySplitsAndRevocationsRecordGeneralT)
                                           (msgs : list (msgToGammaT, timeT)) (lastWoken : timeT) 
                                           (msg : msgToGammaT) (currentMsgDeadline : timeT) =
  requires { forall s . member s g.contractStatuses -> not (applicableRevokeMsgForStatus s sigs msg)}
  ensures  { partyExpectationsFull g sigs p lastWoken msgs = 
             partyExpectationsFull g sigs p lastWoken (Cons (msg, currentMsgDeadline) msgs)}
  assert { moneyInChannelsFull g sigs p lastWoken msgs = moneyInChannelsFull g sigs p lastWoken (Cons (msg, currentMsgDeadline) msgs) };
  (*^unfold moneyInChannelsFull*)
  (*assert {forall x. 
                    worstCaseChannelResolutionFull sigs x p lastWoken msgs = 
                    worstCaseChannelResolutionFull sigs x p lastWoken (Cons (msg, currentMsgDeadline) msgs) };*)
  mapEq (fun x -> transactionNetLossFull x sigs p lastWoken msgs) 
        (fun x ->  transactionNetLossFull x sigs p lastWoken (Cons (msg, currentMsgDeadline) msgs))
        (getSignedGoodTransactions g sigs p.recordOwnerG);
  (*Precondition : unfold transactionNetLossFull*)
  assert { lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken msgs  =
           lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken (Cons (msg, currentMsgDeadline) msgs) }
  (*^unfold lossesInMoveOwnCoinsMsgsFull*)


  
  let lemma gammaProcessMsgInternalNoneNonApplicable (s : contractT) (msg : msgToGammaT) (sigs : signatureFunctionalityT) (time : timeT) = 
  requires { compareContractStatus s.contractStatus (expectedContractStatus msg) }
  requires { contractProcessMsg s msg sigs time = None }
  ensures  { forall s . not (applicableRevokeMsgForStatus s sigs msg) }
  if not verificationCheck msg sigs then assert { forall s . not (applicableRevokeMsgForStatus s sigs msg) } else
  (*^unfold verificationCheckInH; unfold applicableRevokeMsgForStatus*) 
  if not msgApplicable s.contractStatus msg then assert { forall s . not (applicableRevokeMsgForStatus s sigs msg) } else
  (*^unfold verificationCheckInH; unfold applicableRevokeMsgForStatus*) 
  if not timeCheck msg s.lastContractTransitionTime time then assert { forall s . not (applicableRevokeMsgForStatus s sigs msg) } else
  assert { forall s . not (applicableRevokeMsgForStatus s sigs msg) }
  
  let lemma gammaSpendGoodFunding (g : gammaStateT) (channel : contractT) (args : transferFromPublicKeyAccountT) = 
  requires { member channel g.activeContracts }
  requires { gammaCoherent g } 
  requires { goodFunding  (gammaSpendContract g channel) args}
  ensures { goodFunding g args} 
  assert {inputUnspent args (gammaSpendContract g channel)};
  assert { (gammaSpendContract g channel).activeContracts = removeOne channel g.activeContracts};
  assert {inputUnspent args g}
  
  
  let lemma gammaSpendMoneyInChannelsG (g : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                      (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) 
                                      (channel : contractT) = 
  requires { gammaCoherent g } 
  requires { member channel g.activeContracts } 
  ensures { moneyInChannelsFull g sigs p lastWoken msgs = 
            moneyInChannelsFull (gammaSpendContract g channel) sigs p lastWoken msgs + 
            worstCaseChannelResolutionFull sigs channel p lastWoken msgs}
  assert { (gammaSpendContract g channel).activeContracts = removeOne channel g.activeContracts};
  ()
  
  let lemma gammaSpendLossesInMoveOwnCoinsG (g : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                          (channel : contractT) = 
  requires { gammaCoherent g } 
  requires { member channel g.activeContracts } 
  ensures  { lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken msgs >= 
             lossesInMoveOwnCoinsMsgsFull (gammaSpendContract g channel) sigs p lastWoken msgs}
  let newGamma = (gammaSpendContract g channel) in 
  assert { newGamma.activeContracts = removeOne channel g.activeContracts};
  let signedGoodTxsBefore = getSignedGoodTransactions g sigs p.recordOwnerG in 
  let signedGoodTxsAfter = getSignedGoodTransactions newGamma sigs p.recordOwnerG in 
  assert {forall x . num_occ x signedGoodTxsBefore <= 1}; (*finisher*)
  let argsFromSignable = catMaybes (map extractArgsFromSignableTX (getSignedBy sigs (p.recordOwnerG))) in 
  let goodFundingBefore = filter (fun x -> goodFunding g x) argsFromSignable in 
  let goodFundingAfter = filter (fun x -> goodFunding newGamma x) argsFromSignable in 
  let _ = weakerFilterGivesSuperset (fun x -> goodFunding newGamma x) (fun x -> goodFunding g x)  argsFromSignable in 
  assert {forall x. num_occ x goodFundingAfter <= num_occ x goodFundingBefore};
  assert {forall x . member x signedGoodTxsAfter -> member x signedGoodTxsBefore}; 
  assert {forall x. num_occ x signedGoodTxsAfter <= num_occ x signedGoodTxsBefore}; (*finisher*)
  (*^ unfold signedGoodTxsAfter; unfold signedGoodTxsBefore; unfold getSignedGoodTransactions*)
  let valuesBefore = map (fun x -> transactionNetLossFull x sigs p lastWoken msgs) signedGoodTxsBefore in 
  let valuesAfter  = map (fun x -> transactionNetLossFull x sigs p lastWoken msgs) signedGoodTxsAfter in
  assert {forall x . num_occ x valuesAfter <= num_occ x valuesBefore};
  assert {forall x. member x valuesBefore -> exists y . x = transactionNetLossFull y sigs p lastWoken msgs};
  let _ = sumInclusionNonEq valuesAfter valuesBefore in 
  assert {sum valuesAfter <= sum valuesBefore}
  
  let lemma gammaSpendLossesInMoveOwnCoinsSG (g : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                           (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) 
                                           (channel : contractT) (msg : msgToGammaT) =
  requires { gammaCoherent g } 
  requires { member channel g.activeContracts } 
  requires { expectedContractStatus msg = channel.contractStatus }
  requires { goodMsg msg}
  requires { verificationCheck msg sigs}
  ensures  { lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken msgs  >= 
             lossesInMoveOwnCoinsMsgsFull (gammaSpendContract g channel) sigs p lastWoken msgs  +
             msgNetLossGeneral msg sigs p lastWoken msgs} 
  let st = lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken msgs  >= 
            lossesInMoveOwnCoinsMsgsFull (gammaSpendContract g channel) sigs p lastWoken msgs  +
             msgNetLossGeneral msg sigs p lastWoken msgs in 
  match msg with 
    | MoveOwnCoinsOnChain (args, _, _, _) ->
           if not (compareParties args.sender p.recordOwnerG) then assert {st} else (
           let newGamma = (gammaSpendContract g channel) in 
           assert { newGamma.activeContracts = removeOne channel g.activeContracts};
           let signedGoodTxsBefore = getSignedGoodTransactions g sigs p.recordOwnerG in 
           let signedGoodTxsAfter = getSignedGoodTransactions newGamma sigs p.recordOwnerG in 
           assert {forall x . num_occ x signedGoodTxsBefore <= 1}; (*unfold signedGoodTxsBefore; unfold getSignedGoodTransactions*)
           let argsFromSignable = catMaybes (map extractArgsFromSignableTX (getSignedBy sigs (p.recordOwnerG))) in 
           
           assert {member (SignableTX args) (getSignedBy sigs (p.recordOwnerG))};
           assert {member (Some args) (map extractArgsFromSignableTX  (getSignedBy sigs (p.recordOwnerG)))};
           assert {member args argsFromSignable}; 
           
           let goodFundingBefore = filter (fun x -> goodFunding g x) argsFromSignable in 
           let goodFundingAfter = filter (fun x -> goodFunding newGamma x) argsFromSignable in 
           assert {isSpent (expectedContractStatusMoveOwnCoins args) newGamma};
           assert {not (goodFunding newGamma args)};
           assert {not (member args goodFundingAfter)};
           assert {goodFunding g args}; (*unfold goodFunding*)
           assert {member args goodFundingBefore};
           let _ = weakerFilterGivesSuperset (fun x -> goodFunding newGamma x) (fun x -> goodFunding g x)  argsFromSignable in 
           
           assert {forall x. num_occ x goodFundingAfter <= num_occ x goodFundingBefore};
           assert {forall x . member x signedGoodTxsAfter -> member x signedGoodTxsBefore}; (* unfold signedGoodTxsBefore; unfold getSignedGoodTransactions*)
           assert {forall x. num_occ x signedGoodTxsAfter <= num_occ x signedGoodTxsBefore}; (* unfold signedGoodTxsBefore; unfold getSignedGoodTransactions*)
           let _ = sumMapStrictInclusionLeq signedGoodTxsAfter signedGoodTxsBefore (fun x -> transactionNetLossFull x sigs p lastWoken msgs) args in 
          (*^ unfold signedGoodTxsBefore; unfold signedGoodTxsAfter; unfold getSignedGoodTransactions*)
           assert {st})
            
    |  _ ->  let _ = gammaSpendLossesInMoveOwnCoinsG g sigs p lastWoken msgs channel in 
          assert {st}
  end
             
  let lemma gammaSpendContractEvaluatorG (g : gammaStateT) (sigs : signatureFunctionalityT) 
                                      (p : partySplitsAndRevocationsRecordGeneralT) 
                                      (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) 
                                      (channel : contractT) (msg : msgToGammaT) =
  requires { gammaCoherent g }
  requires { member channel g.activeContracts }
  requires { expectedContractStatus msg = channel.contractStatus }
  requires { goodMsg msg}
  requires { verificationCheck msg sigs} 
  ensures  { partyExpectationsFull g sigs p lastWoken msgs  +  msgNetLossGeneral msg sigs p lastWoken msgs <=
             partyExpectationsFull (gammaSpendContract g channel) sigs p lastWoken msgs  + 
             worstCaseChannelResolutionFull sigs channel p lastWoken msgs}
  assert {  moneyInChannelsFull g sigs p lastWoken msgs = 
            moneyInChannelsFull (gammaSpendContract g channel) sigs p lastWoken msgs + 
            worstCaseChannelResolutionFull sigs channel p lastWoken msgs };
  assert { lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken msgs  >= 
             lossesInMoveOwnCoinsMsgsFull (gammaSpendContract g channel) sigs p lastWoken msgs  +
             msgNetLossGeneral msg sigs p lastWoken msgs}
  
  
  let lemma gammaInsertContractsEvaluatorG (g : gammaStateT) (sigs : signatureFunctionalityT)
                                        (p : partySplitsAndRevocationsRecordGeneralT)
                                        (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))
                                        (channels : list contractStatusT) (currentTime : timeT) = 
  requires {forall c . member c channels -> not (member c g.allContracts)}
  (*requires {gammaCoherent g}*)
  ensures { partyExpectationsFull (gammaInsertContracts g channels currentTime) sigs p lastWoken msgs = 
            partyExpectationsFull g sigs p lastWoken msgs + 
            worstCaseChannelsStatusResolutionGeneral sigs channels p lastWoken msgs currentTime}
  assert { moneyInChannelsFull (gammaInsertContracts g channels currentTime) sigs p lastWoken msgs = 
           moneyInChannelsFull g sigs p lastWoken msgs + 
           worstCaseChannelsStatusResolutionGeneral sigs channels p lastWoken msgs currentTime};
  assert { forall x . isSpent x g = isSpent x (gammaInsertContracts g channels currentTime) };
  assert { forall x . goodFunding (gammaInsertContracts g channels currentTime) x = goodFunding g x } ;
  assert { lossesInMoveOwnCoinsMsgsFull (gammaInsertContracts g channels currentTime) sigs p lastWoken msgs  = 
           lossesInMoveOwnCoinsMsgsFull g sigs p lastWoken msgs}
  (*unfold lossesInMoveOwnCoinsMsgsFull; unfold getSignedGoodTransactions; compute_specified; rewrite Assert*)
                                 
 
  let function gammaProcessMsgFreshPreservesEvaluatorFG
                             (g : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (currentTime : timeT) 
                             (p : partySplitsAndRevocationsRecordGeneralT) 
                             (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentMsgDeadline : timeT) : 
                             option gammaStateT = 
  requires {gammaCoherent g}
  requires {checkFreshness msg  g}
  requires {lastWoken <= currentTime <= lastWoken + deltaWake}
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime} 
  ensures  { result = gammaProcessMsgFresh g msg sigState currentTime } 
  ensures  { forall newGamma . result = Some newGamma ->
             partyExpectationsFull newGamma sigState p lastWoken msgs  >= 
             partyExpectationsFull g sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs) }
  let input = expectedContractStatus msg in
  if isSpent_comp input g then None else
  let filtered = filter (fun x -> compareContractStatus x.contractStatus input) g.activeContracts in
    match filtered with
    | Nil -> None
    | Cons inputFull _ ->
      assert { inputFull.contractStatus = input };
      match contractProcessMsg inputFull msg sigState currentTime with
      | None -> None
      | Some newChannels ->
        let gammaWithSpentInput = gammaSpendContract g inputFull in
        assert {gammaWithSpentInput.activeContracts = removeOne inputFull g.activeContracts}; 
        assert { partyExpectationsFull g sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs) + 
                 msgNetLossGeneral msg sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs) <=
                 partyExpectationsFull gammaWithSpentInput sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs) + 
                 worstCaseChannelResolutionFull sigState inputFull p lastWoken (Cons (msg, currentMsgDeadline) msgs) };
        assert { forall x . member x gammaWithSpentInput.contractStatuses -> x <> input };
        assert { forall x . member x gammaWithSpentInput.contractStatuses -> not (applicableRevokeMsgForStatus x sigState msg)};
        assert { partyExpectationsFull gammaWithSpentInput sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs)  = 
                 partyExpectationsFull gammaWithSpentInput sigState p lastWoken  msgs };
        let gammaWithNewInputs = gammaInsertContracts gammaWithSpentInput newChannels currentTime in
        assert {gammaWithNewInputs.activeContracts = (map (fun x -> {lastContractTransitionTime = currentTime; contractStatus = x}) newChannels) ++  removeOne inputFull g.activeContracts};
        assert {forall c . member c newChannels -> contractStatusFreshForGamma g c};
        assert {gammaWithSpentInput.allContracts = g.allContracts};
        assert {forall c. member c g.allContracts = member_comp compareContractStatus c g.allContracts};
        assert {forall c . member c newChannels -> not (member c g.allContracts)};
        gammaInsertContractsEvaluatorG gammaWithSpentInput sigState p lastWoken msgs newChannels currentTime;
        assert { partyExpectationsFull gammaWithNewInputs  sigState p lastWoken msgs  = 
                 partyExpectationsFull gammaWithSpentInput sigState p lastWoken msgs  + 
                 worstCaseChannelsStatusResolutionGeneral sigState newChannels p lastWoken msgs currentTime};
        assert { partyExpectationsFull gammaWithNewInputs  sigState p lastWoken msgs  - 
                 partyExpectationsFull g sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs)  >= 
                 msgDeltaGeneral inputFull msg sigState p lastWoken msgs currentTime currentMsgDeadline};
        let _ =  deltaPositiveG inputFull msg p sigState lastWoken msgs currentTime currentMsgDeadline in
        Some gammaWithNewInputs
      end
    end

    
  let lemma gammaProcessMsgFreshNoneSoNotCorrectRevocation  (g : gammaStateT) (msg : msgToGammaT)
                                                            (sigs : signatureFunctionalityT) (currentTime : timeT) = 
  requires {checkFreshness msg  g}
  requires { gammaProcessMsgFresh g msg sigs currentTime = None}
  ensures  { forall s . member s g.contractStatuses -> not (applicableRevokeMsgForStatus s sigs msg)}
  let input = expectedContractStatus msg in
  if isSpent input g then  assert { forall s . member s g.contractStatuses -> not (applicableRevokeMsgForStatus s sigs msg)} else
  let filtered = filter (fun x -> compareContractStatus x.contractStatus input) g.activeContracts in
    match filtered with
     | Nil ->
       assert { forall s . member s g.activeContracts -> s.contractStatus <> expectedContractStatus msg};
       assert { forall s . member s g.contractStatuses -> s <> expectedContractStatus msg };
       assert { forall s . member s g.contractStatuses -> not (applicableRevokeMsgForStatus s sigs msg)}
     | Cons inputFull _ -> 
       match contractProcessMsg inputFull msg sigs currentTime with
          | None ->  assert  { forall s . member s g.contractStatuses -> not (applicableRevokeMsgForStatus s sigs msg)}
          | Some _ -> absurd
       end
    end
    
  
  let lemma gammaProcessMsgFreshFullPreservesEvaluatorG
                             (g : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (currentTime : timeT) 
                             (p : partySplitsAndRevocationsRecordGeneralT) 
                             (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentMsgDeadline : timeT) =
  requires {checkFreshness msg g}
  requires {gammaCoherent g} 
  requires {lastWoken <= currentTime <= lastWoken + deltaWake}
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime}
  ensures  {  partyExpectationsFull (gammaProcessMsgFreshFull g msg sigState currentTime) sigState p lastWoken msgs  >= 
              partyExpectationsFull g        sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs)  }
  let newGamma = gammaProcessMsgFreshFull g msg sigState currentTime in 
  let st = partyExpectationsFull g sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs)  <=
           partyExpectationsFull newGamma sigState p lastWoken msgs  in 
  match gammaProcessMsgFreshPreservesEvaluatorFG g msg sigState currentTime p lastWoken msgs currentMsgDeadline with 
    | Some x -> assert {x = newGamma}; 
                assert {st};
    | None ->   assert {forall s . member s g.contractStatuses -> not (applicableRevokeMsgForStatus s sigState msg)};
                assert {st}
  end
  
  let lemma gammaProcessFreshMsgPreservesEvaluatorG (g : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (currentTime : timeT)
    (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentMsgDeadline : timeT) (newGamma : gammaStateT) =
  requires { gammaCoherent g }
  requires { lastWoken <= currentTime <= lastWoken + deltaWake }
  requires { forall m t. member (m, t) msgs -> t + deltaNet >= currentTime }
  requires { gammaProcessMsg g msg sigState currentTime = CorrectGamma newGamma }
  ensures {
    partyExpectationsFull newGamma sigState p lastWoken msgs >= 
    partyExpectationsFull g        sigState p lastWoken (Cons (msg, currentMsgDeadline) msgs)
  }
  match gammaProcessMsg g msg sigState currentTime with 
    | AdversaryError -> ()
    | CorrectGamma _newGamma ->
      gammaProcessMsgFreshFullPreservesEvaluatorG g msg sigState currentTime p lastWoken msgs currentMsgDeadline
  end
  
  
end (*EvaluatorPreservationProofs*)

module EvaluatorAdditionalExportedProofs : EvaluatorAdditionalExportedLemmas
(*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

use Gamma
use Evaluator
use basicTypes.BasicTypes

use listLibrary.ListLibrary
use signaturesFunctionality.SignaturesFunctionality
use GammaInvariant
  use Evaluator
  

let lemma gammaAddConsFromVoidPreservesEvaluator (gamma : gammaStateT) (sigState : signatureFunctionalityT) (time : timeT) (p : partySplitsAndRevocationsRecordGeneralT) (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (amount : amountT) (id : idT) (party : partyT) =
requires {amount >= 0}
ensures {partyExpectationsFull (addMoneyFromVoid gamma id amount party time) sigState p lastWoken msgs >= partyExpectationsFull gamma sigState p lastWoken msgs}
let st = partyExpectationsFull (addMoneyFromVoid gamma id amount party time) sigState p lastWoken msgs >= partyExpectationsFull gamma sigState p lastWoken msgs in
if not (idFreshForGamma gamma id) then assert {st} else
let newChannel = PublicKeyAccount amount party id in
let newChannelFull = {contractStatus = PublicKeyAccount amount party id; lastContractTransitionTime = time} in
let newGamma = {activeContracts = Cons newChannelFull gamma.activeContracts; allContracts = Cons newChannel gamma.allContracts} in 
assert {newGamma = addMoneyFromVoid gamma id amount party time};
assert {newChannel.extractAccountId = Some id};
assert {not (member newChannel gamma.allContracts)};
assert {forall x. isSpent x gamma = isSpent x newGamma};
assert {forall x. goodFunding newGamma x = goodFunding gamma x};
assert {forall x. num_occ x (getSignedGoodTransactions gamma sigState p.recordOwnerG) = num_occ x (getSignedGoodTransactions newGamma sigState p.recordOwnerG)};
(*unfold getSignedGoodTransactions*)
assert {lossesInMoveOwnCoinsMsgsFull newGamma sigState p lastWoken msgs = lossesInMoveOwnCoinsMsgsFull gamma sigState p lastWoken msgs};
assert {partyExpectationsFull newGamma sigState p lastWoken msgs >= partyExpectationsFull gamma sigState p lastWoken msgs + worstCaseChannelResolutionFull sigState newChannelFull p lastWoken msgs};
assert {st}
  



  let lemma worstCaseChannelResolutionShuffleMsgsInvariant (channel : contractT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                                           (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {listEq msgs1 msgs2}
  ensures {worstCaseChannelResolution sigs channel p lastWoken msgs1 = worstCaseChannelResolution sigs channel p lastWoken msgs2}
  ()

  let lemma worstCaseChannelResolutionShuffleMsgsInvariantG (channel : contractT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                            (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {listEq msgs1 msgs2}
  ensures {worstCaseChannelResolutionFull sigs channel p lastWoken msgs1 = worstCaseChannelResolutionFull sigs channel p lastWoken msgs2}
  ()

  let lemma correctAndEarlyEnoughChangeIdInvariant (sigs : signatureFunctionalityT) (split : conditionalOutputT) (limit : timeT) (msg : msgToGammaT) (msgDeadline : timeT) (id1 id2 : idT) =
  ensures {correctAndEarlyEnoughRevokeMsg sigs split limit (msg, msgDeadline)  <-> 
           correctAndEarlyEnoughRevokeMsg sigs split limit ((replaceIdsInMsg msg id1 id2), msgDeadline)}
  match msg with
    | OpenDispute _ -> assert {correctAndEarlyEnoughRevokeMsg sigs split limit (msg, msgDeadline) <-> 
                                                correctAndEarlyEnoughRevokeMsg sigs split limit ((replaceIdsInMsg msg id1 id2), msgDeadline)};
    | ClaimAfterTimeout _ -> assert {correctAndEarlyEnoughRevokeMsg sigs split limit (msg, msgDeadline) <-> 
                                                   correctAndEarlyEnoughRevokeMsg sigs split limit ((replaceIdsInMsg msg id1 id2), msgDeadline)};
    | Revoke _ -> assert {correctAndEarlyEnoughRevokeMsg sigs split limit (msg, msgDeadline) <-> 
                                                    correctAndEarlyEnoughRevokeMsg sigs split limit ((replaceIdsInMsg msg id1 id2), msgDeadline)}; (*crush; crushHeavy*)
    | MoveOwnCoinsOnChain _ -> assert {correctAndEarlyEnoughRevokeMsg sigs split limit (msg, msgDeadline) <-> 
                                                 correctAndEarlyEnoughRevokeMsg sigs split limit ((replaceIdsInMsg msg id1 id2), msgDeadline)};
  end

  let lemma worstCaseChannelResolutionChangeIdsInvariant (channel : contractT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                                         (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (msg : msgToGammaT) (msgDeadline : timeT)
                                                         (id1 id2 : idT) =
  ensures { worstCaseChannelResolution sigs channel p lastWoken (Cons (msg, msgDeadline) msgs) = 
            worstCaseChannelResolution sigs channel p lastWoken (Cons (replaceIdsInMsg msg id1 id2, msgDeadline) msgs)}
  let st = worstCaseChannelResolution sigs channel p lastWoken (Cons (msg, msgDeadline) msgs) = 
           worstCaseChannelResolution sigs channel p lastWoken (Cons (replaceIdsInMsg msg id1 id2, msgDeadline) msgs) in
  match channel.contractStatus with 
    | DisputeOpen msplit ->
      assert {correctAndEarlyEnoughRevokeMsg sigs msplit (channel.lastContractTransitionTime + channelTimelock - deltaNet) (msg, msgDeadline) <-> 
              correctAndEarlyEnoughRevokeMsg sigs msplit (channel.lastContractTransitionTime + channelTimelock - deltaNet) (replaceIdsInMsg msg id1 id2, msgDeadline)};
      assert {st};
      (*match msg with 
      | OpenDispute (split, sig, _) -> assert {st};
      | ClaimAfterTimeout (split, sig, _) -> assert {st};
      | Revoke (split, sig, sigSpender, _) -> assert {st};
      | MoveOwnCoinsOnChain (args, sig, _, _)  -> assert {st};
      end*)
    | Normal _ -> assert {st};
    | PublicKeyAccount _ _ _ -> assert {st};
  end

  let lemma worstCaseChannelResolutionChangeIdsInvariantG (channel : contractT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                          (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (msg : msgToGammaT) (msgDeadline : timeT)
                                                          (id1 id2 : idT) =
  ensures { worstCaseChannelResolutionFull sigs channel p lastWoken (Cons (msg, msgDeadline) msgs) =
            worstCaseChannelResolutionFull sigs channel p lastWoken (Cons (replaceIdsInMsg msg id1 id2, msgDeadline) msgs)}
  ()

  let lemma worstCaseChannelResolutionMsgsMonotone (channel : contractT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                                  (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {includedList msgs1 msgs2}
  ensures {worstCaseChannelResolution sigs channel p lastWoken msgs1 <= worstCaseChannelResolution sigs channel p lastWoken msgs2}
  let st = worstCaseChannelResolution sigs channel p lastWoken msgs1 <= worstCaseChannelResolution sigs channel p lastWoken msgs2 in
  match channel.contractStatus with 
    | DisputeOpen _ -> assert {st};
    | Normal _ -> assert {st};
    | PublicKeyAccount _ _ _ -> assert {st};
  end

  let lemma worstCaseChannelResolutionFullMsgsMonotone (channel : contractT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                      (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {includedList msgs1 msgs2}
  ensures {worstCaseChannelResolutionFull sigs channel p lastWoken msgs1 <= worstCaseChannelResolutionFull sigs channel p lastWoken msgs2}
  ()

  let lemma transactionNetLossShuffleMsgsInvariant (tx : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                                  (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {listEq msgs1 msgs2}
  ensures {transactionNetLoss tx sigs p lastWoken msgs1 = transactionNetLoss tx sigs p lastWoken msgs2}
  ()

  let lemma transactionNetLossFullShuffleMsgsInvariant (tx : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                      (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {listEq msgs1 msgs2}
  ensures {transactionNetLossFull tx sigs p lastWoken msgs1 = transactionNetLossFull tx sigs p lastWoken msgs2}
  ()

  let lemma transactionNetLossChangeIdsInvariant (tx : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (msg : msgToGammaT) (msgDeadline : timeT)
                                                 (id1 id2 : idT) =
  ensures { transactionNetLoss tx sigs p lastWoken (Cons (msg, msgDeadline) msgs) =
            transactionNetLoss tx sigs p lastWoken (Cons (replaceIdsInMsg msg id1 id2, msgDeadline) msgs)}
  ()

  let lemma transactionNetLossChangeIdsInvariantFull (tx : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                     (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (msg : msgToGammaT) (msgDeadline : timeT)
                                                     (id1 id2 : idT) =
  ensures { transactionNetLossFull tx sigs p lastWoken (Cons (msg, msgDeadline) msgs) = 
            transactionNetLossFull tx sigs p lastWoken (Cons (replaceIdsInMsg msg id1 id2, msgDeadline) msgs)}
  ()

  let lemma transactionNetLossMsgsMonotone (tx : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                          (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {includedList msgs1 msgs2}
  ensures {transactionNetLoss tx sigs p lastWoken msgs1 >= transactionNetLoss tx sigs p lastWoken msgs2}
  ()

  let lemma transactionNetLossFullMsgsMonotone (tx : transferFromPublicKeyAccountT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                              (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {includedList msgs1 msgs2}
  ensures {transactionNetLossFull tx sigs p lastWoken msgs1 >= transactionNetLossFull tx sigs p lastWoken msgs2}
  ()


  let lemma partyExpectationsMsgIdInvariant (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                           (lastWoken : timeT) (currentMsg : msgToGammaT) (currentMsgDeadline : timeT) (msgs : list (msgToGammaT, timeT))
                                           (id1 id2 : idT) =
  ensures {partyExpectationsFull gamma sigs p lastWoken (Cons (currentMsg, currentMsgDeadline) msgs) = 
           partyExpectationsFull gamma sigs p lastWoken (Cons (replaceIdsInMsg currentMsg id1 id2, currentMsgDeadline) msgs)}
  let msgs1 = (Cons (currentMsg, currentMsgDeadline) msgs) in 
  let msgs2 = (Cons (replaceIdsInMsg currentMsg id1 id2, currentMsgDeadline) msgs) in 
  assert {moneyInChannelsFull gamma sigs p lastWoken msgs1 = moneyInChannelsFull gamma sigs p lastWoken msgs2};
  assert {lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs1 = lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs2}
  

  let lemma partyExpectationsShuffleMsgsInvariant (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                  (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) =
  requires {listEq msgs1 msgs2}
  ensures {partyExpectationsFull gamma sigs p lastWoken msgs1 = partyExpectationsFull gamma sigs p lastWoken msgs2}
  assert {moneyInChannelsFull gamma sigs p lastWoken msgs1 = moneyInChannelsFull gamma sigs p lastWoken msgs2};
  assert {lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs1 = lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs2}

  let lemma partyExpectationsMsgMonotone (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                        (lastWoken : timeT) (msgs1 msgs2 : list (msgToGammaT, timeT)) = 
  requires {includedList msgs1 msgs2}
  ensures {partyExpectationsFull gamma sigs p lastWoken msgs1 <= partyExpectationsFull gamma sigs p lastWoken msgs2}
  assert {moneyInChannelsFull gamma sigs p lastWoken msgs1 <= moneyInChannelsFull gamma sigs p lastWoken msgs2};
  assert {lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs1 >= lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs2}

end (* EvaluatorAdditionalExportedProofs *)

module EvaluatorEquivalentStatementProofs : EvaluatorEquivalentStatementLemmas
  (*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

  use basicTypes.BasicTypes
  use listLibrary.ListLibrary
  (*use basicTypes.ListFunctions*)
  
  use list.Nth
  
  use basicTypes.Compare
  use signaturesFunctionality.SignaturesFunctionality
  (*use partyInterface.PartyInterface*)
  use export Gamma
  use export Evaluator
  use Evaluator
  use GammaInvariant
  use GammaInvariantLemmas
  use EvaluatorBasicLemmas
  use GammaBasicLemmas
  
  let lemma whenNotTracedImmediateExpectedChannelResolutionEq (channel : contractT)
                                  (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  requires {Some p.getTracedChannelId <> channel.contractStatus.extractChannelId }
  ensures  { worstCaseChannelResolution sigs channel p lastWoken msgs = 
             immediateAccountEvaluation channel.contractStatus p.recordOwner }
  let stmt = worstCaseChannelResolution sigs channel p lastWoken msgs = immediateAccountEvaluation channel.contractStatus p.recordOwner in 
  match channel.contractStatus with 
    | Normal _ -> assert {stmt}
    | PublicKeyAccount _ _ _ -> assert {stmt}
    | DisputeOpen _ -> assert {stmt}
  end
  
  let function getTracedChannelIdG (p : partySplitsAndRevocationsRecordGeneralT) : option transferFromPublicKeyAccountT= 
  match makeStrict p with 
    | Some p' -> Some p'.getTracedChannelId
    | None -> None
  end
  
  
  let lemma whenNotTracedImmediateExpectedChannelResolutionEqG (channel : contractT)
                                  (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  requires { p.getTracedChannelIdG = None \/ p.getTracedChannelIdG <> channel.contractStatus.extractChannelId }
  ensures  { worstCaseChannelResolutionFull sigs channel p lastWoken msgs = 
             immediateAccountEvaluation channel.contractStatus p.recordOwnerG }
  let stmt = worstCaseChannelResolutionFull sigs channel p lastWoken msgs = immediateAccountEvaluation channel.contractStatus p.recordOwnerG in 
  match channel.contractStatus with 
    | Normal _ -> assert {stmt}
    | PublicKeyAccount _ _ _ -> assert {stmt}
    | DisputeOpen _ -> assert {stmt}
  end
  
  (*We are going to show that the two evaluators are equal by a sequence of equalities *)
  let function evalTracedChannelOnGamma 
                               (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                               (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))  = 
  let funding = p.getTracedChannelId in 
  match extractChannelByIdFromGamma gamma funding with 
    | Some channel -> worstCaseChannelResolution sigs channel p lastWoken msgs
    | None -> 0
  end
  
  let function evalTracedChannelOnGammaG
                               (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                               (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))  = 
  let funding = p.getTracedChannelIdG in 
  match funding >>= (extractChannelByIdFromGamma gamma)  with 
    | Some channel -> worstCaseChannelResolutionFull sigs channel p lastWoken msgs
    | None -> 0
  end

  
  let function evalTracedInTransactions (gamma : gammaStateT) (sigs : signatureFunctionalityT)
                                 (p : partySplitsAndRevocationsRecordStrictT)
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  let funding = p.getTracedChannelId in 
  match funding.destination with 
      | OtherParty -> 0
      | Void -> 0 
      | Channel -> 
           if not (goodFunding gamma funding && isFunder funding p.recordOwner && isSigned_comp p.recordOwner (SignableTX funding) sigs)
           then 0 else
           worstCaseChannelResolution sigs {contractStatus = (Normal funding); lastContractTransitionTime = currentTime} p lastWoken msgs
  end
   
  let function evalTracedInTransactionsG (gamma : gammaStateT) (sigs : signatureFunctionalityT)
                                 (p : partySplitsAndRevocationsRecordGeneralT)
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  match p.getTracedChannelIdG with 
    | None -> 0
    | Some funding -> 
        match funding.destination with 
          | OtherParty -> 0 
          | Void -> 0
          | Channel ->
            if not (goodFunding gamma funding && isFunder funding p.recordOwnerG && isSigned_comp p.recordOwnerG (SignableTX funding) sigs)
            then 0 else
            worstCaseChannelResolutionFull sigs {contractStatus = (Normal funding); lastContractTransitionTime = currentTime} p lastWoken msgs
        end
  end
  
  let lemma ifExtractThenImmediate0 (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) (p : partyT) = 
  requires { extractChannelByIdFromGamma gamma id = Some channel}
  ensures  { immediateAccountEvaluation channel.contractStatus p = 0}
  let _ = ifExtractThenNotPublicKeyAccount gamma id channel in 
  match channel.contractStatus with 
    | PublicKeyAccount _ _ _ -> absurd 
    | Normal _ -> assert {immediateAccountEvaluation channel.contractStatus p = 0}
    | DisputeOpen _ -> assert {immediateAccountEvaluation channel.contractStatus p = 0}
  end (*destruct_term channel.contractStatus*)
  
  let lemma evalAsImmediateEvals 
                                 (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))  =
  requires {gammaCoherent gamma}
  ensures { immediateAmountOnChain gamma p.recordOwner + evalTracedChannelOnGamma gamma sigs p lastWoken msgs  =
            moneyInChannels gamma sigs p lastWoken msgs }
  let stmt = immediateAmountOnChain gamma p.recordOwner + evalTracedChannelOnGamma gamma sigs p lastWoken msgs =
             moneyInChannels gamma sigs p lastWoken msgs in
  let funding = p.getTracedChannelId in 
  match extractChannelByIdFromGamma gamma funding with 
    | Some channel ->
          assert { forall x y z . channel.contractStatus <> PublicKeyAccount x y z};
          assert {member channel gamma.activeContracts};
          let noTracedChannels = removeOne channel gamma.activeContracts in 
          assert {not (member channel noTracedChannels)};
          let shuffled = Cons channel noTracedChannels in 
          assert { forall x. num_occ x shuffled = num_occ x gamma.activeContracts};
          let sum1 = sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwner)) gamma.activeContracts ) in 
          let sum2 = sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwner))  shuffled ) in 
          assert {sum1 = sum2}; (*cvc 1.4*)
          assert { immediateAmountOnChain gamma p.recordOwner = sum1}; (*unfold immediateAmountOnChain; unfold sum1*)
          assert { immediateAmountOnChain gamma p.recordOwner = sum2};
          assert { sum2 = immediateAccountEvaluation channel.contractStatus p.recordOwner +
                          sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwner))  noTracedChannels )};
          assert { immediateAccountEvaluation channel.contractStatus p.recordOwner = 0};
          assert {sum2 =  sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwner))  noTracedChannels )};
          assert { member channel.contractStatus gamma.contractStatuses };
          assert { forall x. member x gamma.activeContracts -> x.contractStatus = channel.contractStatus -> x = channel };
          assert { channel.contractStatus.extractChannelId = Some funding};
          assert { forall x. member x gamma.activeContracts -> x.contractStatus = channel.contractStatus -> x = channel};
          assert { forall x. member x gamma.activeContracts -> x.contractStatus.extractChannelId = Some funding -> x = channel};
          assert { forall x. member x noTracedChannels -> x.contractStatus.extractChannelId <> Some funding };
          assert { forall x. member x noTracedChannels ->
                             worstCaseChannelResolution sigs x p lastWoken msgs =
                             immediateAccountEvaluation x.contractStatus p.recordOwner };
          let _ = mapEq 
                  (fun (x:contractT) -> immediateAccountEvaluation (x.contractStatus) (p.recordOwner))
                  (fun (x:contractT) -> worstCaseChannelResolution sigs x p lastWoken msgs
                 )
                  noTracedChannels in 
          assert { sum2 =  sum (map (fun x -> worstCaseChannelResolution sigs x p lastWoken msgs)  noTracedChannels)  };
          (*^ rewrite <- Ensures*)
          assert {  worstCaseChannelResolution sigs channel p lastWoken msgs  + 
                    sum (map (fun (x:contractT) -> worstCaseChannelResolution sigs x p lastWoken msgs)  noTracedChannels ) 
                    = 
                     sum (map (fun (x:contractT) -> worstCaseChannelResolution sigs x p lastWoken msgs)  shuffled)};
                     (*^unfold shuffled; rewrite mapCons; rewrite sumInFront; compute_specified*)
          let _ = mapPerm shuffled gamma.activeContracts (fun (x:contractT) -> worstCaseChannelResolution sigs x p lastWoken msgs)  in  
          let _ = sumIsOrderIndependent (map (fun x -> worstCaseChannelResolution sigs x p lastWoken msgs)  shuffled)
                                   (map (fun x -> worstCaseChannelResolution sigs x p lastWoken msgs)  gamma.activeContracts) in (* apply Ensures *)                                    
          assert { sum (map (fun (x:contractT) -> worstCaseChannelResolution sigs x p lastWoken msgs)  shuffled) =
                   sum (map (fun (x:contractT) -> worstCaseChannelResolution sigs x p lastWoken msgs)  gamma.activeContracts)}; (*apply Ensures*)                      
          assert { sum2 + worstCaseChannelResolution sigs channel p lastWoken msgs  = 
                   moneyInChannels gamma sigs p lastWoken msgs}; (* unfold moneyInChannels; rewrite Assert2; rewrite <- Assert; rewrite <- Assert1*)
                                                                  
          assert { stmt };
    | None -> 
        assert { evalTracedChannelOnGamma gamma sigs p lastWoken msgs = 0};
        assert { forall c . member c gamma.contractStatuses -> c.extractChannelId <> Some p.getTracedChannelId};
        let _ = mapEq
            (fun (x:contractT) -> immediateAccountEvaluation (x.contractStatus) (p.recordOwner))
            (fun (x:contractT) ->
                  worstCaseChannelResolution sigs x p lastWoken msgs)
            gamma.activeContracts in (*cvc1.4*)
        assert { immediateAmountOnChain gamma p.recordOwner = moneyInChannels gamma sigs p lastWoken msgs}; 
        assert { stmt };
  end
  
  let lemma evalAsImmediateEvalsG (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT))  =
  requires {gammaCoherent gamma}
  ensures { immediateAmountOnChain gamma p.recordOwnerG + evalTracedChannelOnGammaG gamma sigs p lastWoken msgs =
            moneyInChannelsFull gamma sigs p lastWoken msgs }      
  let stmt = immediateAmountOnChain gamma p.recordOwnerG + evalTracedChannelOnGammaG gamma sigs p lastWoken msgs =
             moneyInChannelsFull gamma sigs p lastWoken msgs in
  match p.getTracedChannelIdG >>= (extractChannelByIdFromGamma gamma) with 
    | Some channel ->
          assert { forall x y z . channel.contractStatus <> PublicKeyAccount x y z};
          assert { member channel gamma.activeContracts };
          let noTracedChannels = removeOne channel gamma.activeContracts in 
          assert {not (member channel noTracedChannels)};
          let shuffled = Cons channel noTracedChannels in 
          assert { forall x. num_occ x shuffled = num_occ x gamma.activeContracts};
          let sum1 = sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwnerG)) gamma.activeContracts ) in 
          let sum2 = sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwnerG))  shuffled ) in 
          assert {sum1 = sum2}; (*cvc 1.4*)
          assert { immediateAmountOnChain gamma p.recordOwnerG = sum1}; (*unfold immediateAmountOnChain*)
          assert { immediateAmountOnChain gamma p.recordOwnerG = sum2};
          assert { sum2 = immediateAccountEvaluation channel.contractStatus p.recordOwnerG +
                          sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwnerG))  noTracedChannels )};
          assert { immediateAccountEvaluation channel.contractStatus p.recordOwnerG = 0};
          assert {sum2 =  sum (map (fun (x1:contractT) -> immediateAccountEvaluation (x1.contractStatus) (p.recordOwnerG))  noTracedChannels )};
          assert { member channel.contractStatus gamma.contractStatuses };
          assert { forall x. member x gamma.activeContracts -> x.contractStatus = channel.contractStatus -> x = channel };
          assert { channel.contractStatus.extractChannelId = p.getTracedChannelIdG}; (*unfold extractChannelId; unfold getTracedChannelIdG*)
          assert { forall x. member x gamma.activeContracts -> x.contractStatus = channel.contractStatus -> x = channel};
          assert { forall x. member x gamma.activeContracts -> x.contractStatus.extractChannelId = p.getTracedChannelIdG -> x = channel};
          assert { forall x. member x noTracedChannels -> x.contractStatus.extractChannelId <> p.getTracedChannelIdG };
          assert { forall x. member x noTracedChannels ->
                             worstCaseChannelResolutionFull sigs x p lastWoken msgs =
                             immediateAccountEvaluation x.contractStatus p.recordOwnerG };
          let _ = mapEq
                  (fun (x:contractT) -> immediateAccountEvaluation (x.contractStatus) (p.recordOwnerG))
                  (fun (x:contractT) -> worstCaseChannelResolutionFull sigs x p lastWoken msgs
                 )
                  noTracedChannels in 
          assert { sum2 =  sum (map (fun x -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  noTracedChannels)  };
          (*^ rewrite <- Ensures*)
          assert {  worstCaseChannelResolutionFull sigs channel p lastWoken msgs  + 
                    sum (map (fun (x:contractT) -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  noTracedChannels ) 
                    = 
                    sum (map (fun (x:contractT) -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  shuffled)};
                    (*^unfold shuffled; rewrite mapCons; rewrite sumInFront; compute_specified*) 
          let _ = mapPerm shuffled gamma.activeContracts (fun (x:contractT) -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  in  
          let _ = sumIsOrderIndependent (map (fun x -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  shuffled)
                                   (map (fun x -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  gamma.activeContracts) in (* apply Ensures *)                                    
          assert { sum (map (fun (x:contractT) -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  shuffled) =
                   sum (map (fun (x:contractT) -> worstCaseChannelResolutionFull sigs x p lastWoken msgs)  gamma.activeContracts)}; (*apply Ensures*)                      
          assert { sum2 + worstCaseChannelResolutionFull sigs channel p lastWoken msgs  = 
                   moneyInChannelsFull gamma sigs p lastWoken msgs};
                   (*^ unfold moneyInChannelsFull; rewrite Assert2; rewrite <- Assert; rewrite <- Assert1 *)
          assert { stmt };
    | None -> 
        assert { evalTracedChannelOnGammaG gamma sigs p lastWoken msgs = 0};
        assert { forall c . member c gamma.contractStatuses -> ((c.extractChannelId = None) \/ c.extractChannelId <> p.getTracedChannelIdG)};
        let _ = mapEq
            (fun (x:contractT) -> immediateAccountEvaluation (x.contractStatus) (p.recordOwnerG))
            (fun (x:contractT) ->
                  worstCaseChannelResolutionFull sigs x p lastWoken msgs)
            gamma.activeContracts in (*cvc1.4*)
        assert { immediateAmountOnChain gamma p.recordOwnerG = moneyInChannelsFull gamma sigs p lastWoken msgs}; 
        assert { stmt };
  end

  let lemma whenNotTracedArgsLossesAsImmediateLosses (args : transferFromPublicKeyAccountT)
                                  (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  requires { p.getTracedChannelId <> args }
  ensures  { transactionNetLoss args sigs p lastWoken msgs  =
             immediateTransactionNetLoss p.recordOwner args (*args*) (*sigs*) }
  () 
  
  let lemma whenNotTracedArgsLossesAsImmediateLossesG (args : transferFromPublicKeyAccountT)
                                  (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) = 
  requires { p.getTracedChannelIdG <> Some args }
  ensures  { transactionNetLossFull args sigs p lastWoken msgs  =
             immediateTransactionNetLoss p.recordOwnerG args }
  () 
  
  let lemma goodTransactionsSpec (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partyT) (args : transferFromPublicKeyAccountT) =
  requires {isSigned p (SignableTX args) sigs}
  requires {goodFunding gamma args }
  ensures { member args (getSignedGoodTransactions gamma sigs p) }
  let l1 = getSignedBy sigs p in 
  let l2 = map extractArgsFromSignableTX l1 in
  let l3 = catMaybes l2 in 
  let l4 = filter (goodFunding gamma) l3 in
  let l5 = makeUnique_comp compareArgs l4 in 
  assert { exists sig. verify p (SignableTX args) sig sigs };
  assert { member (SignableTX args) l1 }; 
  assert { member (Some args) l2 }; 
  assert { member args l3 };
  let _ = filterAndMember (goodFunding gamma) l3 args in 
  assert { member_comp compareArgs args l4 };
  assert { member_comp compareArgs args l5 };
  assert { l5 = getSignedGoodTransactions gamma sigs p }
  
  let lemma goodTransactionsSpec2 (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partyT) (args : transferFromPublicKeyAccountT) =
  requires { member args (getSignedGoodTransactions gamma sigs p) }
  ensures { isSigned p (SignableTX args) sigs }
  ensures { goodFunding gamma args }
  let l1 = getSignedBy sigs p in 
  let l2 = map extractArgsFromSignableTX l1 in
  let l3 = catMaybes l2 in 
  let l4 = filter (goodFunding gamma) l3 in
  let l5 = makeUnique l4 in 
  assert { member args l5 };
  assert { member args l4 };
  assert { member args l3 };
  assert { member (Some args) l2 };
  assert { forall x. extractArgsFromSignableTX x = Some args -> x = SignableTX args };
  assert { member  (SignableTX args) l1 }

  let lemma transactionLossesAsImmediateLosses 
                                 (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  requires { gammaCoherent gamma }
  ensures  { lossesInMoveOwnCoinsMsgs gamma sigs p lastWoken msgs  = 
             immediateLossesInMoveOwnCoinsMsgs gamma sigs p.recordOwner - 
             evalTracedInTransactions gamma sigs p lastWoken msgs currentTime}
  let stmt = lossesInMoveOwnCoinsMsgs gamma sigs p lastWoken msgs  = 
             immediateLossesInMoveOwnCoinsMsgs gamma sigs p.recordOwner -
             evalTracedInTransactions gamma sigs p lastWoken msgs currentTime in 
  let funding = p.getTracedChannelId in 
  let goodSigned = getSignedGoodTransactions gamma sigs p.recordOwner in 
  match member funding goodSigned with 
    | True ->
        let otherArgs = removeOne funding goodSigned in 
        let shuffled = Cons funding otherArgs in 
        assert {forall x. num_occ x shuffled = num_occ x goodSigned};
        assert {forall x. member x otherArgs -> 
                            transactionNetLoss x sigs p lastWoken msgs  = 
                            immediateTransactionNetLoss p.recordOwner x};
        let otherArgsLosses = sum (map (fun x -> transactionNetLoss x sigs p lastWoken msgs ) otherArgs) in 
        let otherArgsImmediateLosses =  sum (map (fun x -> immediateTransactionNetLoss p.recordOwner x) otherArgs) in 
        assert { otherArgsLosses = otherArgsImmediateLosses };  
        let shuffledLosses = sum (map (fun x -> transactionNetLoss x sigs p lastWoken msgs ) shuffled) in 
        let shuffledImmediateLosses =  sum (map (fun x -> immediateTransactionNetLoss p.recordOwner x) shuffled) in
        match funding.destination with 
          | Void
          | OtherParty (*This really should not happen, because p should be tracing a channel and not a 
                         normal account. But really does not break anything, so we might as well just prove it*) ->
                         assert { immediateTransactionNetLoss p.recordOwner funding  = 
                                  transactionNetLoss funding sigs p lastWoken msgs };
                         assert { shuffledLosses = shuffledImmediateLosses };
                         assert { evalTracedInTransactions gamma sigs p lastWoken msgs currentTime = 0 };
                         assert { stmt }; 
          | Channel -> 
                         assert { transferFromPublicKeyAccountCorrect funding };
                         assert { immediateTransactionNetLoss p.recordOwner funding = fundsInvested funding (p.recordOwner) };
                         
                         assert {goodFunding gamma funding};
                         assert {isSigned (p.recordOwner) (SignableTX funding) sigs};
                         assert { transactionNetLoss funding sigs p lastWoken msgs  = 
                                  fundsInvested funding (p.recordOwner) - 
                                  evalTracedInTransactions gamma sigs p lastWoken msgs currentTime };
                         assert { shuffledLosses = shuffledImmediateLosses - evalTracedInTransactions gamma sigs p lastWoken msgs currentTime};
                         let totalLosses = sum (map (fun x -> transactionNetLoss x sigs p lastWoken msgs ) goodSigned) in 
                         let totalImmediateLosses =  sum (map (fun x -> immediateTransactionNetLoss p.recordOwner x) goodSigned) in
                         let _ =  mapPerm shuffled goodSigned (fun x -> transactionNetLoss x sigs p lastWoken msgs ) in 
                         let _ =  mapPerm shuffled goodSigned (fun x -> immediateTransactionNetLoss p.recordOwner x) in 
                         let _ =  sumIsOrderIndependent (map (fun x -> transactionNetLoss x sigs p lastWoken msgs ) shuffled)
                                                        (map (fun x -> transactionNetLoss x sigs p lastWoken msgs ) goodSigned)
                                                        (*apply Ensures1*) in 
                         let _ =  sumIsOrderIndependent (map (fun x -> immediateTransactionNetLoss p.recordOwner x) shuffled)
                                                        (map (fun x -> immediateTransactionNetLoss p.recordOwner x) goodSigned)
                                                        (*apply Ensures1*) in 
                         assert { shuffledLosses = totalLosses};
                         assert { shuffledImmediateLosses = totalImmediateLosses };
                                 (*^ unfold totalImmediateLosses; unfold shuffledImmediateLosses; rewrite Ensures; compute_specified. *)
                         assert { totalImmediateLosses = shuffledImmediateLosses };                                 
                         assert { lossesInMoveOwnCoinsMsgs gamma sigs p lastWoken msgs  = totalLosses };
                         (*^ unfold lossesInMoveOwnCoinsMsgs; unfold totalLosses*)
                         assert { immediateLossesInMoveOwnCoinsMsgs gamma sigs p.recordOwner = totalImmediateLosses };
                         (*rewrite Assert1; unfold immediateLossesInMoveOwnCoinsMsgs; unfold goodSigned in Ensures; rewrite <- Ensures*)
                         assert {stmt}; (*rewrite Assert; rewrite Assert1; rewrite <- Assert4; rewrite Assert2 *)
        end
    | False -> 
       if (isSigned p.recordOwner (SignableTX funding) sigs) && (goodFunding gamma funding) then 
           let _ = goodTransactionsSpec gamma sigs p.recordOwner funding in 
           absurd 
       else 
           assert { not (isSigned p.recordOwner (SignableTX funding)) sigs \/ not (goodFunding gamma funding) };
           assert { evalTracedInTransactions gamma sigs p lastWoken msgs currentTime = 0};
           assert {stmt}; (* rewrite Assert*)
   end
   
  let lemma transactionLossesAsImmediateLossesG 
                                 (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  requires { gammaCoherent gamma }
  ensures  { lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs  = 
             immediateLossesInMoveOwnCoinsMsgs gamma sigs p.recordOwnerG - 
             evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime}
  let stmt = lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs   = 
             immediateLossesInMoveOwnCoinsMsgs gamma sigs p.recordOwnerG -
             evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime in 
  let goodSigned = getSignedGoodTransactions gamma sigs p.recordOwnerG in 
  match p.getTracedChannelIdG with 
    | None -> assert {stmt};
    | Some funding ->
        match member funding goodSigned with 
          | True -> 
              let otherArgs = removeOne funding goodSigned in 
              let shuffled = Cons funding otherArgs in 
              assert {forall x. num_occ x shuffled = num_occ x goodSigned};
              assert {forall x. member x otherArgs -> 
                                  transactionNetLossFull x sigs p lastWoken msgs = 
                                  immediateTransactionNetLoss p.recordOwnerG x};
              let otherArgsLosses = sum (map (fun x -> transactionNetLossFull x sigs p lastWoken msgs) otherArgs) in 
              let otherArgsImmediateLosses =  sum (map (fun x -> immediateTransactionNetLoss p.recordOwnerG x) otherArgs) in 
              assert { otherArgsLosses = otherArgsImmediateLosses };  
              let shuffledLosses = sum (map (fun x -> transactionNetLossFull x sigs p lastWoken msgs ) shuffled) in 
              let shuffledImmediateLosses =  sum (map (fun x -> immediateTransactionNetLoss p.recordOwnerG x) shuffled) in
              match funding.destination with 
                | Void 
                | OtherParty (*This really should not happen, because p should be tracing a channel and not a 
                               normal account. But really does not break anything, so we might as well just prove it*) ->
                               assert { immediateTransactionNetLoss p.recordOwnerG funding  = 
                                        transactionNetLossFull funding sigs p lastWoken msgs };
                               assert { shuffledLosses = shuffledImmediateLosses };
                               assert { evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime = 0 };
                               assert { stmt }; (*finisher*)
                | Channel -> 
                               assert { transferFromPublicKeyAccountCorrect funding };
                               assert { immediateTransactionNetLoss p.recordOwnerG funding = fundsInvested funding (p.recordOwnerG) };
                               
                               assert {goodFunding gamma funding};
                               assert {isSigned (p.recordOwnerG) (SignableTX funding) sigs};
                               assert { transactionNetLossFull funding sigs p lastWoken msgs  = 
                                        fundsInvested funding (p.recordOwnerG) - 
                                        evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime }; (*unfold transactionNetLossFull*)
                               assert { shuffledLosses = shuffledImmediateLosses - evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime};
                               let totalLosses = sum (map (fun x -> transactionNetLossFull x sigs p lastWoken msgs ) goodSigned) in 
                               let totalImmediateLosses =  sum (map (fun x -> immediateTransactionNetLoss p.recordOwnerG x) goodSigned) in
                               let _ =  mapPerm shuffled goodSigned (fun x -> transactionNetLossFull x sigs p lastWoken msgs ) in 
                               let _ =  mapPerm shuffled goodSigned (fun x -> immediateTransactionNetLoss p.recordOwnerG x) in 
                               let _ =  sumIsOrderIndependent (map (fun x -> transactionNetLossFull x sigs p lastWoken msgs ) shuffled)
                                                              (map (fun x -> transactionNetLossFull x sigs p lastWoken msgs ) goodSigned)
                                                              (*apply Ensures1*) in 
                               let _ =  sumIsOrderIndependent (map (fun x -> immediateTransactionNetLoss p.recordOwnerG x) shuffled)
                                                              (map (fun x -> immediateTransactionNetLoss p.recordOwnerG x) goodSigned)
                                                              (*apply Ensures1*) in 
                               assert { shuffledLosses = totalLosses};
                               assert { shuffledImmediateLosses = totalImmediateLosses };
                                       (*^ unfold totalImmediateLosses; unfold shuffledImmediateLosses; rewrite Ensures; compute_specified. *)
                               assert { totalImmediateLosses = shuffledImmediateLosses };
                               assert { lossesInMoveOwnCoinsMsgsFull gamma sigs p lastWoken msgs  = totalLosses };
                                       (*^ unfold lossesInMoveOwnCoinsMsgsFull; unfold totalLosses*)
                               assert { immediateLossesInMoveOwnCoinsMsgs gamma sigs p.recordOwnerG = totalImmediateLosses };
                               (*rewrite Assert1; unfold immediateLossesInMoveOwnCoinsMsgs; unfold goodSigned in Ensures; rewrite <- Ensures*)
                               assert {stmt}; (*rewrite Assert; rewrite Assert1; rewrite <- Assert4; rewrite Assert2 *)
              end
          | False -> 
             if (isSigned p.recordOwnerG (SignableTX funding) sigs) && (goodFunding gamma funding) then 
                 let _ = goodTransactionsSpec gamma sigs p.recordOwnerG funding in 
                 absurd 
             else 
                 assert { not (isSigned p.recordOwnerG (SignableTX funding)) sigs \/ not (goodFunding gamma funding) };
                 assert { evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime = 0};
                 assert {stmt}; (*rewrite Assert; unfold lossesInMoveOwnCoinsMsgsFull; unfold immediateLossesInMoveOwnCoinsMsgs*)
       end
   end

  let lemma channelExpectationsGammaOrTransactions (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                                   (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  requires { gammaCoherent gamma}
  ensures  { channelExpectations gamma sigs p lastWoken msgs currentTime = 
             evalTracedChannelOnGamma gamma sigs p lastWoken msgs +
             evalTracedInTransactions gamma sigs p lastWoken msgs currentTime }
  let stmt = channelExpectations gamma sigs p lastWoken msgs currentTime = 
             evalTracedChannelOnGamma gamma sigs p lastWoken msgs +
             evalTracedInTransactions gamma sigs p lastWoken msgs currentTime in 
  let test = filter (fun x -> compareOption compareArgs (extractChannelId (x.contractStatus)) (Some (getTracedChannelId p))) gamma.activeContracts in 
  assert { test = filter (fun x -> compareOption compareArgs (extractChannelId (x.contractStatus)) (Some (getTracedChannelId p))) gamma.activeContracts}; 
  match p.getTracedChannelId.destination with
        | Void -> 
            match test with 
              | Nil  ->  assert {stmt}; (*unfold evalTracedChannelOnGamma*)
              | Cons x _ ->
                 assert {member x.contractStatus gamma.contractStatuses};
                 assert {((x.contractStatus.extractChannelId <&> destination)) = Some Void};
                 match x.contractStatus with 
                   | Normal _ -> absurd
                   | DisputeOpen _ -> absurd 
                   | PublicKeyAccount _ _ _ -> absurd 
                 end
            end
        | OtherParty ->
            match test with 
              | Nil  ->  assert {stmt}; (*unfold evalTracedChannelOnGamma*)
              | Cons x _xs ->
                 assert {member x.contractStatus gamma.contractStatuses}; 
                 assert {((x.contractStatus.extractChannelId <&> destination)) = Some OtherParty};
                 match x.contractStatus with 
                   | Normal _ -> absurd
                   | DisputeOpen _ -> absurd 
                   | PublicKeyAccount _ _ _ -> absurd 
                 end
            end
        | Channel -> match extractChannelByIdFromGamma gamma (getTracedChannelId p) with 
                       | None -> assert{stmt};
                       | Some channel ->
                            assert {num_occ channel gamma.activeContracts > 0}; 
                            assert {extractChannelId channel.contractStatus = Some (getTracedChannelId p)};
                            assert {not (inputUnspent (getTracedChannelId p) gamma)};
                            assert {not (goodFunding gamma (getTracedChannelId p))};
                            assert {evalTracedInTransactions gamma sigs p lastWoken msgs currentTime = 0};
                            assert {stmt};
                      end
  end
  
  let lemma channelExpectationsGammaOrTransactionsG (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                                    (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) = 
  requires { gammaCoherent gamma}
  ensures  { channelExpectationsG gamma sigs p lastWoken msgs currentTime = 
            evalTracedChannelOnGammaG gamma sigs p lastWoken msgs +
            evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime}
  let stmt = (channelExpectationsG gamma sigs p lastWoken msgs currentTime = 
            evalTracedChannelOnGammaG gamma sigs p lastWoken msgs +
            evalTracedInTransactionsG gamma sigs p lastWoken msgs currentTime) in 
  let test = filter (fun x -> compareOption compareArgs (extractChannelId (x.contractStatus)) p.getTracedChannelIdG) gamma.activeContracts in 
  assert { test = filter (fun x -> compareOption compareArgs (extractChannelId x.contractStatus) p.getTracedChannelIdG) gamma.activeContracts}; 
  match p.getTracedChannelIdG<&>destination with
        | Some OtherParty ->
            match test with 
              | Nil  ->
                let _x = any transferFromPublicKeyAccountT ensures {p.getTracedChannelIdG = Some result} in      
                assert {stmt}; (*unfold channelExpectationsG; unfold evalTracedChannelOnGammaG*)
              | Cons x _ ->
                 assert {member x.contractStatus gamma.contractStatuses}; 
                 assert {((x.contractStatus.extractChannelId <&> destination)) = Some OtherParty};
                 match x.contractStatus with 
                   | Normal _ -> absurd
                   | DisputeOpen _ -> absurd 
                   | PublicKeyAccount _ _ _ -> absurd 
                 end
            end
        | Some Void ->
            match test with 
              | Nil  ->
                let _x = any transferFromPublicKeyAccountT ensures {p.getTracedChannelIdG = Some result} in      
                assert {stmt}; (*unfold channelExpectationsG; unfold evalTracedChannelOnGammaG*)
              | Cons x _ ->
                 assert {member x.contractStatus gamma.contractStatuses}; 
                 assert {((x.contractStatus.extractChannelId <&> destination)) = Some Void};
                 match x.contractStatus with 
                   | Normal _ -> absurd
                   | DisputeOpen _ -> absurd 
                   | PublicKeyAccount _ _ _ -> absurd 
                 end
              end
        | None -> assert {stmt};
        | Some Channel -> match (getTracedChannelIdG p) >>= (extractChannelByIdFromGamma gamma)  with 
                       | None -> assert{stmt}; (*finisher*)
                       | Some channel ->
                            let x = any transferFromPublicKeyAccountT ensures {p.getTracedChannelIdG = Some result} in 
                            assert {num_occ channel gamma.activeContracts > 0}; (*cvc 4*)
                            assert {extractChannelId channel.contractStatus = p.getTracedChannelIdG};
                            assert {inputUnspent x gamma = false};
                            assert {goodFunding gamma x = false}; 
                            assert {stmt}; (*unfold channelExpectationsG; unfold evalTracedChannelOnGammaG*)
                      end
  end                          
  
  let lemma partyExpectationsEqual (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordStrictT) 
                                  (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  requires { gammaCoherent gamma }
  ensures {partyExpectations gamma sigs p lastWoken msgs  = partyExpectations2 gamma sigs p lastWoken msgs currentTime}
  let stmt = ( partyExpectations gamma sigs p lastWoken msgs  = partyExpectations2 gamma sigs p lastWoken msgs currentTime ) in
  let _ = transactionLossesAsImmediateLosses gamma sigs p lastWoken msgs currentTime in 
  let _ = evalAsImmediateEvals gamma sigs p lastWoken msgs in 
  assert {channelExpectations gamma sigs p lastWoken msgs currentTime = 
          evalTracedChannelOnGamma gamma sigs p lastWoken msgs +
          evalTracedInTransactions gamma sigs p lastWoken msgs currentTime};
          
  assert {stmt}
  
  let lemma partyExpectationsEqualG (gamma : gammaStateT) (sigs : signatureFunctionalityT) (p : partySplitsAndRevocationsRecordGeneralT) 
                                 (lastWoken : timeT) (msgs : list (msgToGammaT, timeT)) (currentTime : timeT) =
  requires { gammaCoherent gamma }
  ensures {partyExpectationsFull gamma sigs p lastWoken msgs  = partyExpectations2G gamma sigs p lastWoken msgs currentTime} 
  let stmt = ( partyExpectationsFull gamma sigs p lastWoken msgs  = partyExpectations2G gamma sigs p lastWoken msgs currentTime ) in
  match makeStrict p with 
    | None -> assert {stmt};
    | Some x -> let _ = partyExpectationsEqual gamma sigs x lastWoken msgs currentTime in 
                assert {stmt}
  end
 

  
end (*Evaluator equivalence proof for party*)

module GammaProcessMsgProofs : GammaProcessMsgLemmas
(*This module follows the Statement-Proof separation convention. See the comment in honestPartyVsAdversary.mlw/ClosingWorksLemmas for more details.*)

use basicTypes.BasicTypes

use listLibrary.ListLibrary
use basicTypes.Compare
use signaturesFunctionality.SignaturesFunctionality
use Gamma
use GammaInvariant
use GammaInvariantLemmas
use EvaluatorBasicLemmas
use list.Append

  let lemma ifOnChannelThanExtract (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) (channel : contractT) =
  requires {member channel gamma.activeContracts}
  requires {gammaCoherent gamma}
  requires {channel.contractStatus.extractChannelId = Some id}
  ensures {extractChannelByIdFromGamma gamma id = Some channel}
  match  extractChannelByIdFromGamma gamma id with 
  | None -> ifNoExtractThenNoOnChannel gamma id; absurd
  | Some channel' -> 
    assert {member channel' gamma.activeContracts};
    fullChannelUniqueByFounding gamma channel channel' id;
    assert {channel' = channel}
  end

  let lemma ifNotOnChannelThenNoExtract (gamma : gammaStateT) (id : transferFromPublicKeyAccountT) =
  requires {forall x. member x gamma.activeContracts -> x.contractStatus.extractChannelId <> Some id}
  ensures {extractChannelByIdFromGamma gamma id = None}
  ()

  let lemma gammaProcessMsgFreshSomeSoExistsMsgFull (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) =
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  ensures {exists x. member x g1.activeContracts /\ x.contractStatus = expectedContractStatus msg}
  if not (checkFreshness msg g1) then absurd else
  let input = expectedContractStatus msg in
  if isSpent input g1 then absurd else
  let filtered = filter (fun x -> compareContractStatus x.contractStatus input) g1.activeContracts in
  match filtered with
  | Nil -> absurd
  | Cons inputFull _ -> 
    assert {member inputFull g1.activeContracts};
    assert {inputFull.contractStatus = expectedContractStatus msg};
    assert {exists x. member x g1.activeContracts /\ x.contractStatus = expectedContractStatus msg} 
  end
  
  
  
  let lemma gammaProcessMsgFreshSomeSpec (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractT) =
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {member ch g1.activeContracts}
  requires {ch.contractStatus = expectedContractStatus msg}
  ensures {g2 = gammaProcessMsgDirect g1 msg time ch}
  if not (checkFreshness msg g1) then absurd else
  let input = expectedContractStatus msg in
  assert {input = ch.contractStatus};
  if isSpent input g1 then absurd else
  let filtered = filter (fun x -> compareContractStatus x.contractStatus input) g1.activeContracts in
  match filtered with
  | Nil -> absurd
  | Cons inputFull _ ->
    assert { inputFull.contractStatus = input };
    assert {inputFull = ch};
    match contractProcessMsg inputFull msg sigState time with
    | None -> absurd
    | Some newChannels ->
      let gammaWithSpentInput = gammaSpendContract g1 inputFull in 
      let gammaWithNewInputs = gammaInsertContracts gammaWithSpentInput newChannels time in 
      assert {g2 = gammaWithNewInputs};
      assert {gammaWithNewInputs = gammaProcessMsgDirect g1 msg time ch};
    end
  end

  let lemma gammaProcessMsgContractStatuses (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractStatusT) =
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires { (member ch g1.contractStatuses /\ ch <> expectedContractStatus msg) \/ member ch (evalOut msg)}
  ensures {member ch g2.contractStatuses}
  let input = expectedContractStatus msg in
  let inputFull = any contractT ensures {member result g1.activeContracts /\ result.contractStatus = input} in
  assert {forall x l. member x l -> member_comp compareContractStatus x l}; 
  gammaProcessMsgFreshSomeSpec g1 g2 msg sigState time inputFull;
  if member ch g1.contractStatuses && not (compareContractStatus ch (expectedContractStatus msg)) then 
    assert {member ch g2.contractStatuses} (*finisher*)
  else (
    assert {member ch msg.evalOut};
    assert {member ch (map contractStatus  ( (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) (evalOut msg))) )  }; (*finisher*)
    assert { member ch (map contractStatus  ( (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) (evalOut msg)) ++ removeOne_comp compareSimpleChannel inputFull (g1.activeContracts))) };
    assert {member ch g2.contractStatuses}
  )

  let lemma gammaProcessMsgContractStatuses2 (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractStatusT) =
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {member ch g2.contractStatuses}
  ensures { (member ch g1.contractStatuses /\ ch <> expectedContractStatus msg) \/ member ch (evalOut msg)}
  let input = expectedContractStatus msg in
  let inputFull = any contractT ensures {member result g1.activeContracts /\ result.contractStatus = input} in

  gammaProcessMsgFreshSomeSpec g1 g2 msg sigState time inputFull; 
  assert {member ch (map contractStatus  ( (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) (evalOut msg)) ++ removeOne_comp compareSimpleChannel inputFull (g1.activeContracts))) };
  assert {member ch (map contractStatus  (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) (evalOut msg))) \/ member ch (map contractStatus (removeOne_comp compareSimpleChannel inputFull (g1.activeContracts)) ) };
  if member_comp compareContractStatus ch (map contractStatus  (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) (evalOut msg))) then (
    assert {member ch (map contractStatus  (map (fun x -> {contractStatus = x; lastContractTransitionTime = time}) (evalOut msg)))};
    assert {member ch (evalOut msg)} (*rewrite mapCompose in Assert*)
  ) else (
    assert {member ch (map contractStatus (removeOne_comp compareSimpleChannel inputFull (g1.activeContracts)))};
    assert {member ch g1.contractStatuses};
    assert {ch <> inputFull.contractStatus};
    assert {member ch g1.contractStatuses};
  )

  let lemma gammaProcessMsgActiveContracts (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractT) =
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {(member ch g1.activeContracts /\ ch.contractStatus <> expectedContractStatus msg) \/ (ch.lastContractTransitionTime = time /\ member ch.contractStatus (evalOut msg))}
  ensures {member ch g2.activeContracts}
  let input = expectedContractStatus msg in
  let inputFull = any contractT ensures {member result g1.activeContracts /\ result.contractStatus = input} in
  gammaProcessMsgFreshSomeSpec g1 g2 msg sigState time inputFull;
  assert {member ch g2.activeContracts} (*finisher*)

  let lemma gammaProcessMsgActiveContracts2 (g1 g2 : gammaStateT) (msg : msgToGammaT) (sigState : signatureFunctionalityT) (time : timeT) (ch : contractT) =
  requires {gammaCoherent g1}
  requires {gammaCoherent g2}
  requires {gammaProcessMsgFresh g1 msg sigState time = Some g2}
  requires {member ch g2.activeContracts}
  ensures {(member ch g1.activeContracts /\ ch.contractStatus <> expectedContractStatus msg) \/ (ch.lastContractTransitionTime = time /\ member ch.contractStatus (evalOut msg))}
  let input = expectedContractStatus msg in
  let inputFull = any contractT ensures {member result g1.activeContracts /\ result.contractStatus = input} in
  gammaProcessMsgFreshSomeSpec g1 g2 msg sigState time inputFull;
  assert {member ch (removeOne_comp compareSimpleChannel inputFull g1.activeContracts) \/ member ch (map (fun x -> {contractStatus = x; lastContractTransitionTime = time }) (evalOut msg))};
  assert {(member ch g1.activeContracts /\ ch.contractStatus <> expectedContractStatus msg) \/ (ch.lastContractTransitionTime = time /\ member ch.contractStatus (evalOut msg))}

end (*GammaProcessMsgProofs*)
